<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-TW">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



















  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="ruopu&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="ruopu&#39;s blog">
<meta property="og:locale" content="zh-TW">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ruopu&#39;s blog">






  <link rel="canonical" href="http://yoursite.com/page/12/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ruopu's blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-TW">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ruopu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切換導航欄">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首頁</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />標籤</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分類</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />歸檔</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜尋</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜尋..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/jdyc测试环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/jdyc测试环境搭建/" itemprop="url">
                  jdyc测试环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-30 10:56:33 / 修改時間：11:59:11" itemprop="dateCreated datePublished" datetime="2018-09-30T10:56:33+08:00">2018-09-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/test/" itemprop="url" rel="index"><span itemprop="name">test</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h1><p>IP：10.5.5.242</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ansible</span><br><span class="line">vim /etc/ansible/hosts</span><br><span class="line">	[ansible]</span><br><span class="line">    10.5.5.242</span><br><span class="line"></span><br><span class="line">    [web]</span><br><span class="line">    10.5.5.223</span><br><span class="line"></span><br><span class="line">    [netty]</span><br><span class="line">    10.5.5.221</span><br><span class="line">    10.5.5.222</span><br><span class="line"></span><br><span class="line">    [wechat]</span><br><span class="line">    10.5.5.224</span><br><span class="line">    10.5.5.227</span><br><span class="line"></span><br><span class="line">    [processor]</span><br><span class="line">    10.5.5.228</span><br><span class="line">    10.5.5.229</span><br><span class="line"></span><br><span class="line">    [mysql]</span><br><span class="line">    10.5.5.238</span><br><span class="line">    10.5.5.239</span><br><span class="line"></span><br><span class="line">    [kafka]</span><br><span class="line">    10.5.5.232</span><br><span class="line">    10.5.5.233</span><br><span class="line">    10.5.5.234</span><br><span class="line"></span><br><span class="line">    [redis]</span><br><span class="line">    10.5.5.235</span><br><span class="line">    10.5.5.236</span><br><span class="line">    10.5.5.237</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -P ''</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub 10.5.5.237</span><br><span class="line"><span class="meta">#</span><span class="bash">将密钥复制到ansible中加入的所有主机，实现无密钥登录</span></span><br><span class="line">ansible web,wechat,processor -m shell -a "yum install -y java-1.8.0-openjdk-devel"</span><br><span class="line">ansible web,wechat,processor -m shell -a "rpm -q java-1.8.0-openjdk-devel"</span><br><span class="line">ansible redis -m shell -a "yum install -y epel-release"</span><br><span class="line">ansible redis -m shell -a "yum install -y redis"</span><br><span class="line">ansible web,wechat,processor -m shell -a "yum install -y epel-release"</span><br><span class="line">ansible web,wechat,processor -m shell -a "yum install -y nginx"</span><br><span class="line"></span><br><span class="line">* web</span><br><span class="line">mkdir -pv /root/nginx/&#123;web,wechat&#125;</span><br><span class="line">vim /root/nginx/web/web.conf</span><br><span class="line">	proxy_cache_path /etc/nginx/cache levels=1:2:2 keys_zone=web_cache:10m max_size=2g;</span><br><span class="line">    server&#123;</span><br><span class="line">       server_name web.jdyichong.com;</span><br><span class="line">       index index.html index.htm;</span><br><span class="line">       charset utf-8;</span><br><span class="line">       proxy_cache web_cache;</span><br><span class="line">       proxy_cache_key $request_uri;</span><br><span class="line">       proxy_cache_methods GET HEAD;</span><br><span class="line">       proxy_cache_min_uses 1;</span><br><span class="line">       proxy_cache_valid 200 302 10m;</span><br><span class="line">       proxy_cache_valid 400 1m;</span><br><span class="line">       proxy_cache_use_stale http_502;</span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">            proxy_pass http://10.5.5.223:8081;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">ansible web -m copy -a "src=/root/nginx/web/web.conf dest=/etc/nginx/conf.d"</span><br><span class="line">ansible web -m command -a "systemctl start nginx"</span><br><span class="line">ansible web -m command -a "systemctl enable nginx"</span><br><span class="line"><span class="meta">#</span><span class="bash">设置web服务器上的nginx启动并加入开机启动。测试时这里有报错，不能启动nginx，原因是使用了OpenVZ的模板，此模板中安装了httpd服务，并且开机启动，需要关闭。</span></span><br></pre></td></tr></table></figure>
<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><p>IP：10.5.5.223</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/27/iptables概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/iptables概念/" itemprop="url">
                  iptables概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-27 10:49:11" itemprop="dateCreated datePublished" datetime="2018-09-27T10:49:11+08:00">2018-09-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2019-01-15 10:11:00" itemprop="dateModified" datetime="2019-01-15T10:11:00+08:00">2019-01-15</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/防火墙/" itemprop="url" rel="index"><span itemprop="name">防火墙</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="防火墙概念"><a href="#防火墙概念" class="headerlink" title="防火墙概念"></a>防火墙概念</h1><ul>
<li><p>主机防火墙：针对于单个主机进行防护。</p>
</li>
<li><p>网络防火墙：往往处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。网络防火墙和主机防火墙并不冲突，可以理解为，网络防火墙主外（集体）， 主机防火墙主内（个人）。</p>
</li>
<li><p>iptables是工作在linux内核中的网络防火墙，netfilter才是防火墙真正的安全框架（framework），iptables和netfilter是一组工具，真正起到防火墙作用的是netfilter，netfilter是内核中的一個過濾框架，iptables是一個生成防火牆規則，並能將其符加在netfilter上，真正實現數據報文過濾、NAT、mangle等規則生成的工具。</p>
</li>
<li><p>防火牆工作在主機或網絡的邊緣，對進出的數據報文進行檢查監控，按事先定義的規則進行相應處理。防火牆可以是硬件或軟件，規則包括匹配標準和處理辦法。</p>
</li>
<li><p>防火牆規則必須放在內核上，因爲我們是不能和內核打交道的，有人在內核的TCP/IP協議棧上開放了幾個位置，開放給用戶空間的應用程序</p>
</li>
<li><p>netfile就是內核中可以放規則的位置；iptables是工作在用戶空間可以寫規則並可通過系統調用放置在內核相應位置的應用程序；報文流向有三種：進來的，出去的和轉發的，在<code>/proc/sys/net/ipv4/ip_forward</code>中就是定義是否轉發的；根據IP地址完成路由表中的路由決策，無論從哪進來的只要到了TCPIP協議棧後，下一個就是路由決策</p>
</li>
<li><p>Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p>
<p>网络地址转换(Network Address Translate)</p>
<p>数据包内容修改</p>
<p>以及数据包过滤的防火墙功能</p>
</li>
</ul>
<h1 id="iptables概念"><a href="#iptables概念" class="headerlink" title="iptables概念"></a>iptables概念</h1><ul>
<li>当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。当客户端发来的报文访问的目标地址是其他服务器时，本机的内核要支持IP_FORWARD，我们就可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”链”，他们就是  “路由前”、”转发”、”路由后”，他们的英文名是：PREROUTING、FORWARD、POSTROUTING。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。</li>
</ul>
<p><img src="/images/iptables/朱双印2.jpg"></p>
<ul>
<li><p>报文的流向：</p>
<p>到本机某进程的报文：PREROUTING –&gt; INPUT</p>
<p>由本机转发的报文：PREROUTING –&gt; FORWARD –&gt; POSTROUTING</p>
<p>由本机的某进程发出报文（通常为响应报文）：OUTPUT –&gt; POSTROUTING</p>
</li>
<li><p>将具有相同功能的规则放在一起就是“表”</p>
</li>
<li><p>hook function：鈎子函數，有五個位置。分別是input（進）, output（出）, forward（轉發）, prerouting（路由做出前）, postrouting（路由之後再發出）</p>
</li>
<li><p>鈎子函數的規則鏈：INPUT，OUTPUT，FORWARD，PREROUTING，POSTROUTING；</p>
</li>
<li><p>PREROUTING的规则可以存在于：raw表，mangle表，nat表。</p>
<p>INPUT的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</p>
<p>FORWARD的规则可以存在于：mangle表，filter表。</p>
<p>OUTPUT的规则可以存在于：raw表，mangle表，nat表，filter表。</p>
<p>POSTROUTING的规则可以存在于：mangle表，nat表。</p>
</li>
<li><p>filter表：INPUT，OUTPUT，FORWARD；负责过滤功能；内核模块：iptables_filter</p>
</li>
<li><p>nat表：PREROUTING，POSTROUTING，OUTPUT（centos7中还有INPUT，centos6中没有）；network address translation，网络地址转换功能；内核模块：iptable_nat</p>
</li>
<li><p>mangle表：INPUT，OUTPUT，FORWARD，PREROUTING，POSTROUTING；拆解报文，做出修改，并重新封装報文首部的功能；内核模块：iptable_mangle</p>
</li>
<li><p>過濾與mangle是不能放在一起的；</p>
</li>
<li><p>raw表：PREROUTING，OUTPUT；关闭nat表上启用的连接追踪机制；iptable_raw</p>
</li>
<li><p>iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。</p>
<p>优先级次序（由高而低）：</p>
<p>raw –&gt; mangle –&gt; nat –&gt; filter</p>
<p>某些链天生就不能使用某些表中的规则，所以，4张表中的规则处于同一条链的目前只有output链</p>
</li>
<li><p>数据转发流程</p>
</li>
</ul>
<p><img src="/images/iptables/朱双印数据转发流程.jpg"></p>
<ul>
<li>INPUT、OUTPUT是從內核空間到用戶空間實現過濾的，是主機防火牆設置，通過本機轉發的通過FORWARD鏈，是網絡防火牆的設置。路由的轉發功能可以是一臺主機上的兩個網段的地址。一臺交換機上可以配置多個網段的地址，但它們之間不能通信，但如果不同網段的主機的網關指向了一臺網關服務器上一塊網卡的兩個不同網段的地址，且服務器上開通了路由的功能，那麼就可以通信了；因爲IP地址不是屬於網卡的，而是屬於主機的，所以一塊網卡可以连接兩個網絡</li>
<li>啓用了ip_forward鏈，默認所有報文都要轉發</li>
<li>應該隔離可以被公網訪問的主機與不能被公網訪問的主機，如在網關服務器上放三塊網卡，其中一塊是面對互聯網的，另一塊是面對內網的，最後一塊面對服務器，開放互聯網訪問時只能從面對互聯網的網卡到面對服務器的網卡；所有在面對內網網卡上的報文要想進來必須得是一個響應，其他不允許，網關服務器被叫做三宿主的主機</li>
<li>netfilter：是一個框架，在TCP/IP協議橈上有5個鈎子函數分別對應5個規則鏈，工作在內核中。不能手動向netfilter中添加數據，要用iptables編寫規則送達netfilter的某個鏈上，但它必須先屬於某張表。默認表是filter，還有nat、mangle表</li>
<li>目標地址轉換在進入時改，源地址轉換在出去的時候改。</li>
<li>可以使用自定義鏈，但只在被默認鏈調用時才能發揮作用，而且如果沒有自定義鏈中的任何規則匹配，還應該有返回機制。用戶可以刪除自定義的空鏈，默認鏈不能刪除。</li>
<li>每個規則都有兩個內置的計數器，一個記錄被匹配的報文個數，一個記錄被匹配的報文大小之和</li>
<li>DNAT：目標地址轉換，轉換IP報文中的目標IP地址。目標地址轉換DNAT，指在返回結果時將地址轉換爲請求的地址。如一臺服務器上沒有服務，但将其設置成轉換到后端兩臺服務器的地址，一臺80一臺21,用户訪問時訪問的是這臺沒有服務的主機，但返回結果是有服務的兩臺主機的內容，在返回結果時就要將地址轉換成沒有服務的主機的IP。也就是当用户访问一个地址时，这个地址本没有服务，但可将此请求转到相应的地址服务上，并在服务返回结果时自动将源地址转为用户请求的地址，这就是目标地址转换。源地址转换与目标地址转换效果相反。我们只操作一半，另一半转换由服务器自动完成</li>
<li>SNAT：源地址轉換，轉換IP報文中的源IP地址（可在POSTROUTING或OUTPUT上做，對網關來講只在POSTROUTING上作）。雖然稱爲源地址轉換，但目標IP地址也會轉換，只不過回程的目標地址會轉換</li>
<li>在互聯網上發送報文的時候，無論經過任何路由設備源IP與目標IP是不會改變的</li>
<li>對linux主機而言，IP地址是屬於主機的，不屬於網卡,配在什麼網卡上並不重要，關鍵是是否屬於這臺主機，無論是否打開轉發功能。這裏所說指一臺主機ping自己的網關地址，在網關這臺主機上的IP網關地址即使不在一個網段上也沒有開轉發功能，同樣可以被ping通。只有在ping第三臺網關指向這臺網關主機另一個網段IP的主機時，才需要轉發。</li>
<li>對linux主機而言，IP地址是屬於主機的，不屬於網卡,配在什麼網卡上並不重要，關鍵是是否屬於這臺主機，無論是否打開轉發功能。這裏所說指一臺主機ping自己的網關地址，在網關這臺主機上的IP網關地址即使不在一個網段上也沒有開轉發功能，同樣可以被ping通。只有在ping第三臺網關指向了這臺網關主機另一個網段IP的主機時，才需要轉發。</li>
<li>涉及到轉發與本機無關時一定是在FORWARD鏈上做</li>
<li>iptables在二三四層上進行過濾</li>
</ul>
<h2 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h2><ul>
<li><p>ACCEPT：允许数据包通过。</p>
</li>
<li><p>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</p>
</li>
<li><p>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</p>
</li>
<li><p>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</p>
</li>
<li><p>MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</p>
</li>
<li><p>DNAT：目标地址转换。</p>
</li>
<li><p>REDIRECT：在本机做端口映射。</p>
</li>
<li><p>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</p>
</li>
</ul>
<h2 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h2><ul>
<li><p>filter表——过滤数据包</p>
</li>
<li><p>Nat表——用于网络地址转换（IP、端口）</p>
</li>
<li><p>Mangle表——修改数据包的服务类型、TTL、并且可以配置路由实现QOS</p>
</li>
<li><p>Raw表——决定数据包是否被状态跟踪机制处理</p>
</li>
</ul>
<ul>
<li>INPUT链——进来的数据包应用此规则链中的策略</li>
<li>OUTPUT链——外出的数据包应用此规则链中的策略</li>
<li>FORWARD链——转发数据包时应用此规则链中的策略</li>
<li>PREROUTING链——对数据包作路由选择前应用此链中的规则（所有的数据包进来的时侯都先由这个链处理）</li>
<li>POSTROUTING链——对数据包作路由选择后应用此链中的规则（所有的数据包出来的时侯都先由这个链处理）</li>
</ul>
<p><img src="/images/iptables/四表五链详细.jpg" alt=""></p>
<p><img src="/images/iptables/四表五链.png" alt=""></p>
<p><img src="/images/iptables/四表五链鸟哥.jpg" alt=""></p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul>
<li>NEW：新連接請求。主机连接目标主机，在目标主机上看到的第一个想要连接的包</li>
<li>ESTABLISHED：已建立的連接。主机已与目标主机进行通信，判断标准只要目标主机回应了第一个包，就进入该状态。</li>
<li>INVALID：非法連接請求。无效的封包，例如数据破损的封包状态</li>
<li>RELATED：相關聯的。主机已与目标主机进行通信，目标主机发起新的链接方式，例如ftp</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/27/iptables使用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/iptables使用方法/" itemprop="url">
                  iptables使用方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-27 10:49:11" itemprop="dateCreated datePublished" datetime="2018-09-27T10:49:11+08:00">2018-09-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2018-09-29 16:24:36" itemprop="dateModified" datetime="2018-09-29T16:24:36+08:00">2018-09-29</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/防火墙/" itemprop="url" rel="index"><span itemprop="name">防火墙</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="防火墙概念"><a href="#防火墙概念" class="headerlink" title="防火墙概念"></a>防火墙概念</h1><blockquote>
<p>&emsp;&emsp;iptables是工作在linux内核中的网络防火墙，iptables和netfilter是一组工具，真正起到防火墙作用的是netfilter，netfilter是内核中的一個過濾框架，iptables是一個生成防火牆規則，並能將其符加在netfilter上，真正實現數據報文過濾、NAT、mangle等規則生成的工具。</p>
<p>&emsp;&emsp;防火牆工作在主機或網絡的邊緣，對進出的數據報文進行檢查監控，按事先定義的規則進行相應處理。防火牆可以是硬件或軟件，規則實施防火，規則包括匹配標準和處理辦法。</p>
<p>&emsp;Framework:</p>
<p>&emsp;默認規則：</p>
<p>&emsp;如果防火牆默認是全部開放的，那就用堵的辦法</p>
<p>&emsp;如果防火牆默認是全部關閉的，那就用通的辦法</p>
<p>&emsp;&emsp;防火牆規則必須放在內核上，因爲我們是不能和內核打交道的，有人在內核的TCP/IP協議棧上開放了幾個位置，開放給用戶空間的應用程序</p>
<p>&emsp;&emsp;netfile就是內核中可以放規則的位置；iptables是工作在用戶空間可以寫規則並可通過系統調用放置在內核相應位置的應用程序；報文流向有三種：進來的，出去的和轉發的，在/proc/sys/net/ipv4/ip_forward中就是定義是否轉發的；根據IP地址完成路由表中的路由決策，無論從哪進來的只要到了TCPIP協議棧後的下一個就是路由決策</p>
</blockquote>
<h1 id="iptables概念"><a href="#iptables概念" class="headerlink" title="iptables概念"></a>iptables概念</h1><blockquote>
<ul>
<li><p>hook function：鈎子函數，有五個位置。分別是input（進）, output（出）, forward（轉發）, prerouting（路由做出前）, postrouting（路由之後再發出）</p>
</li>
<li><p>鈎子函數的規則鏈：INPUT，OUTPUT，FORWARD，PREROUTING，POSTROUTING；</p>
</li>
<li><p>filter（過濾）：表：INPUT，OUTPUT，FORWARD；</p>
</li>
<li><p>nat（地址轉換）：表：PREROUTING，POSTROUTING，OUTPUT；</p>
</li>
<li><p>mangle（拆開、修改、封裝報文首部）：表：INPUT，OUTPUT，FORWARD，PREROUTING，POSTROUTING；</p>
</li>
<li><p>過濾與mangle是不能放在一起的；</p>
</li>
<li><p>raw()：表：PREROUTING，OUTPUT</p>
</li>
<li>IINPUT、OUTPUT是從內核空間到用戶空間實現過濾的，是主機防火牆設置，通過本機轉發的通過FORWARD鏈，是網絡防火牆的設置。路由的轉發功能可以是一臺主機上的兩個網段的地址.一臺交換機上可以配置多個網段的地址，但它們之間不能通信，但如果不同網段的主機的網關指向了一臺網關服務器上一塊網卡的兩個不同網段的地址，且服務器上開通了路由的功能，那麼就可以通信了；因爲IP地址不是屬於網卡的，而是屬於主機的，所以一塊網卡可以邊接兩個網絡</li>
<li>啓用了ip_forward鏈，默認所有報文都要轉發</li>
<li><p>應該隔離可以被公網訪問的主機與不能被公網訪問的主機，如在網關服務器上放三塊網卡，其中一塊是面對互聯網的，另一塊是面對內網的，最後一塊面對服務器，開放互聯網訪問時只能從面對互聯網的網卡到面對服務器的網卡；所有在面對內網網卡上的報文要想進來必須得是一個響應，其他不允許，網關服務器被叫做三宿主的主機</p>
</li>
<li><p>netfilter:是一個框架，在TCP/IP協議橈上有5個鈎子函數分別對應5個規則鏈，工作在內核中。不能手動向netfilter中添加數據，要用iptables編寫規則送達netfilter的某個鏈上，但它必須先屬於某張表。默認表是filter，還有nat、mangle表</p>
</li>
<li><p>目標地址轉換在進入時改，源地址轉換在出去的時候改。</p>
</li>
<li><p>可以使用自定義鏈，但只在被默認鏈調用時才能發揮作用，而且如果沒有自定義鏈中的任何規則匹配，還應該有返回機制。用戶可以刪除自定義的空鏈，默認鏈不能刪除。</p>
</li>
<li><p>每個規則都有兩個內置的計數器，一個記錄被匹配的報文個數，一個記錄被匹配的報文大小之和</p>
</li>
<li><p>NAT：Network Address Translation</p>
</li>
<li>DNAT：目標地址轉換，轉換IP報文中的目標IP地址。目標地址轉換DNAT，指在返回結果時將地址轉換爲請求的地址。如一臺服務器上沒有服務，但将其設置成轉換到后端兩臺服務器的地址，一臺80一臺21,用户訪問時訪問的是這臺沒有服務的主機，但返回結果是有服務的兩臺主機的內容，在返回結果時就要將地址轉換成沒有服務的主機的IP。也就是当用户访问一个地址时，这个地址本没有服务，但可将此请求转到相应的地址服务上，并在服务返回结果时自动将源地址转为用户请求的地址，这就是目标地址转换。源地址转换与目标地址转换效果相反。我们只操作一半，另一半转换由服务器自动完成</li>
<li>SNAT：源地址轉換，轉換IP報文中的源IP地址（可在POSTROUTING或OUTPUT上做，對網關來講只在POSTROUTING上作）。雖然稱爲源地址轉換，但目標IP地址也會轉換，只不過回程的目標地址會轉換</li>
<li>在互聯網上發送報文的時候，無論經過任何路由設備源IP與目標IP是不會改變的</li>
<li>對linux主機而言，IP地址是屬於主機的，不屬於網卡,配在什麼網卡上並不重要，關鍵是是否屬於這臺主機，無論是否打開轉發功能。這裏所說指一臺主機ping自己的網關地址，在網關這臺主機上的IP網關地址即使不在一個網段上也沒有開轉發功能，同樣可以被ping通。只有在ping第三臺網關指向這臺網關主機另一個網段IP的主機時，才需要轉發。</li>
<li>對linux主機而言，IP地址是屬於主機的，不屬於網卡,配在什麼網卡上並不重要，關鍵是是否屬於這臺主機，無論是否打開轉發功能。這裏所說指一臺主機ping自己的網關地址，在網關這臺主機上的IP網關地址即使不在一個網段上也沒有開轉發功能，同樣可以被ping通。只有在ping第三臺網關指向了這臺網關主機另一個網段IP的主機時，才需要轉發。</li>
<li>涉及到轉發與本機無關時一定是在FORWARD鏈上做</li>
<li>iptables在二三四層上進行過濾</li>
<li></li>
</ul>
</blockquote>
<h2 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h2><ul>
<li><p>filter表——过滤数据包</p>
</li>
<li><p>Nat表——用于网络地址转换（IP、端口）</p>
</li>
<li><p>Mangle表——修改数据包的服务类型、TTL、并且可以配置路由实现QOS</p>
</li>
<li><p>Raw表——决定数据包是否被状态跟踪机制处理</p>
</li>
</ul>
<ul>
<li>INPUT链——进来的数据包应用此规则链中的策略</li>
<li>OUTPUT链——外出的数据包应用此规则链中的策略</li>
<li>FORWARD链——转发数据包时应用此规则链中的策略</li>
<li>PREROUTING链——对数据包作路由选择前应用此链中的规则（所有的数据包进来的时侯都先由这个链处理）</li>
<li>POSTROUTING链——对数据包作路由选择后应用此链中的规则（所有的数据包出来的时侯都先由这个链处理）</li>
</ul>
<p><img src="/images/iptables/四表五链详细.jpg" alt=""></p>
<p><img src="/images/iptables/四表五链.png" alt=""></p>
<p><img src="/images/iptables/四表五链鸟哥.jpg" alt=""></p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>NEW：新連接請求。主机连接目标主机，在目标主机上看到的第一个想要连接的包<br>ESTABLISHED：已建立的連接。主机已与目标主机进行通信，判断标准只要目标主机回应了第一个包，就进入该状态。<br>INVALID：非法連接請求。无效的封包，例如数据破损的封包状态<br>RELATED：相關聯的。主机已与目标主机进行通信，目标主机发起新的链接方式，例如ftp</p>
<h1 id="规则及语法"><a href="#规则及语法" class="headerlink" title="规则及语法"></a>规则及语法</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t TABLE] COMMAND CHAIN [num] 匹配條件 -j 處理動作</span><br></pre></td></tr></table></figure>
<h2 id="規則：匹配標準"><a href="#規則：匹配標準" class="headerlink" title="規則：匹配標準"></a>規則：匹配標準</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">通用匹配：自身能夠檢查</span><br><span class="line">    -s, --src</span><br><span class="line">    #指定源地址</span><br><span class="line">    -d, --dst</span><br><span class="line">    #指定目標地址       </span><br><span class="line">    -p &#123;tcp|udp|icmp&#125;</span><br><span class="line">    #指定協議</span><br><span class="line">    -i eth* </span><br><span class="line">    #指定數據報文流入的接口，可用於自定義鏈，和以下鏈PREROUTING，INPUT，FORWARD</span><br><span class="line">    -o INTERFACE</span><br><span class="line">    #指定數據報文流出的接口，可用於標準定義的鏈和以下鏈OUTPUT,POSTROUTING,FORWARD</span><br><span class="line"></span><br><span class="line">擴展匹配：依賴模塊才能檢查，在/lib/iptables下的.so擴展模塊</span><br><span class="line">	隱含擴展：不用特別指明由哪個模塊進行的擴展，因爲此時使用-p &#123;tcp|udp|icmp&#125;</span><br><span class="line">	-p tcp</span><br><span class="line">		--sport PORT [-PORT]</span><br><span class="line"><span class="meta">		#</span><span class="bash">源端口；可使用連續端口</span></span><br><span class="line">		--dport PORT [-PORT]</span><br><span class="line"><span class="meta">		#</span><span class="bash">目標端口</span></span><br><span class="line">		--tcp-flags mask comp</span><br><span class="line"><span class="meta">		#</span><span class="bash">只檢查mask指定的標志位，是逗號分隔的標志位列表；comp：此列表中出現的標記位必須爲1；comp中沒出現，而mask中出現的，必須爲0；如：</span></span><br><span class="line">		--tcp-flags SYN，FIN，ACK，RST SYN，ACK 等同 --syn選項</span><br><span class="line"><span class="meta">		#</span><span class="bash">檢查tcp報文的 SYN，FIN，ACK，RST標志位，這些標志位中只能是SYN，ACK爲1，其他爲0</span></span><br><span class="line">		--syn：三次握手的第一次</span><br><span class="line">	-p icmp</span><br><span class="line">		--icmp-type</span><br><span class="line"><span class="meta">		#</span><span class="bash">icmp協議報文的類型，主要有0和8兩種,我們ping別人的時候出去的是8進來的是0,別人ping我們的時候進來的是8出去的是0</span></span><br><span class="line">		0：echo-reply	</span><br><span class="line"><span class="meta">		#</span><span class="bash">響應報文</span></span><br><span class="line">		8：echo-request    </span><br><span class="line"><span class="meta">		#</span><span class="bash">請求報文</span></span><br><span class="line">	-p udp</span><br><span class="line">		--sport</span><br><span class="line">		--dport</span><br><span class="line"></span><br><span class="line">	顯式擴展：必須指明由哪個模塊進行的擴展，在iptables中使用-m選項可完成此功能</span><br><span class="line">	-m EXTESTION_NAME -specific-opt(-m 擴展名 擴展選項)</span><br><span class="line">		* state：#狀態擴展</span><br><span class="line">			--state</span><br><span class="line">			結合ip_conntrack追蹤會話的狀態，有四種，跟據IP、連接追蹤</span><br><span class="line">			NEW：#新連接請求</span><br><span class="line">			ESTABLISHED：#已建立的連接</span><br><span class="line">			INVALID：#非法連接請求</span><br><span class="line">			RELATED：#相關聯的</span><br><span class="line">		例：</span><br><span class="line">		-m state --state NEW -j ACCEPT		</span><br><span class="line"><span class="meta">		#</span><span class="bash">只檢查NEW狀態，狀態爲NEW的可以通過</span></span><br><span class="line">		-m state --state NEW,ESTABLISHED -j ACCEPT		</span><br><span class="line"><span class="meta">		#</span><span class="bash">狀態爲NEW和ESTABLISHED的全部放行，與地址，協誶無關</span></span><br><span class="line"></span><br><span class="line">		* multiport：#多端口匹配擴展，可實現離散的多端口匹配</span><br><span class="line">			--source-ports：#源端口</span><br><span class="line">			--destination-ports：#目標端口</span><br><span class="line">			--ports：#不論是上面兩種哪一種端口；另外多個端口可用逗號隔開，但最多只能有15個</span><br><span class="line">		例：</span><br><span class="line">		-m multiport --destination-ports 21,22,80 -j ACCEPT</span><br><span class="line">			</span><br><span class="line">		* iprange：#指定IP範圍</span><br><span class="line">			--src-range</span><br><span class="line">			--dst-range</span><br><span class="line">		例：</span><br><span class="line">		iptables -A INPUT -p tcp -m iprange --src-range 172.16.100.3-172.16.100.100 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT			</span><br><span class="line"><span class="meta">		#</span><span class="bash">源IP是100.3到100的，可以訪問目標端口22,狀態要是NEW或ESTABLISHED</span></span><br><span class="line"></span><br><span class="line">		* connlimit：#連接數限定，也就是線程數，如只能使用5個連接請求</span><br><span class="line">			! --connlimit-above n：#connlimit的上限，但這裏是達到n個</span><br><span class="line">		例：本機的web服務器最多允許同時發起兩個請求進來</span><br><span class="line">        iptables -A INPUT -d 172.16.100.7 -p tcp --dport 80 -m connlimit ! --connlimit-above 2 -j ACCEPT</span><br><span class="line">        #這是沒達到2個就允許，所以一般要在--connlimit-above前加！號。如果不加！号，可改ACCEPT的狀態爲DROP或REJECT了</span><br><span class="line"></span><br><span class="line">		* limit</span><br><span class="line">        	--limit RATE：給的是一個速率，如每秒多少人</span><br><span class="line">            --limit-burst：給的是一個上限，第一批可放行多少個</span><br><span class="line">		例：</span><br><span class="line">		iptables -I INPUT -d 172.16.100.7 -p tcp --dport 22 -m limit --limit 3/minute --limit-burst 3 -j ACCEPT	</span><br><span class="line"><span class="meta">		#</span><span class="bash">每分鍾放行3個，最多一次擁入3個</span></span><br><span class="line">		iptables -R INPUT 3 -d 172.6.100.7 -p icmp --icmp-type 8 -m limit --limit 5/minute --limit-burst 6 -j ACCEPT		</span><br><span class="line"><span class="meta">		#</span><span class="bash">修改第三條規則爲限定每分種5個ping請求，但前6個是很快的</span></span><br><span class="line">		測試，連續打開多個ssh連接服務器</span><br><span class="line"></span><br><span class="line">		* string </span><br><span class="line">        	--algo &#123;bm|kmp&#125;：#指定算法</span><br><span class="line">            --string "STRING"：#指定字符串，支持正則</span><br><span class="line">        例：</span><br><span class="line">        vim /var/www/html/test.html</span><br><span class="line">        	h7n9 </span><br><span class="line">            hello world</span><br><span class="line">		iptables -I INPUT -d 172.16.100.7 -m string --algo kmp --string "h7n9" -j REJECT</span><br><span class="line"><span class="meta">		#</span><span class="bash">上面這條是匹配不到的，因爲當用戶的請求中沒有h7n9，請求頁面時，我們響應的報文是從OUTPUT響應出去的，所以應將規則寫在OUTPUT上</span></span><br><span class="line">		iptables -R OUTPUT 1 -s 172.16.100.7 -m string --algo kmp --string "h7n9" -j REJECT</span><br><span class="line"><span class="meta">		#</span><span class="bash">不能訪問有h7n9的頁面 ,-R選項是修改之意。</span></span><br><span class="line"><span class="meta">		#</span><span class="bash">iptables -L -n -v顯示信息中的pkts是匹配到的規則</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">管理規則</span><br><span class="line">    -A：#附加一條規則，在鏈的尾部追加</span><br><span class="line">    -I CHAIN [num]：#插入一條規則，可以指定添加在什麼位置，插入爲對應CHAIN上的第num條，如果省略num則插入爲第一條</span><br><span class="line">    -D CHAIN [num]：#刪除指定鏈中的第num條規則；</span><br><span class="line">    -R CHAIN [num]：#替換指定的規則</span><br><span class="line"></span><br><span class="line">管理鏈</span><br><span class="line">    -F [CHAIN]：#flush：清空指定規則鏈，如果省略CHAIN，則可以實現刪除對應表中的所有鏈</span><br><span class="line">    -p CHAIN：#設定指定鏈的默認策略</span><br><span class="line">    -N：#自定義一個新的空鏈</span><br><span class="line">    -X：#刪除一個自定議的空鏈</span><br><span class="line">    -Z：#置零指定鏈中所有規則的計數器</span><br><span class="line">    -E：#重命名自定義的鏈</span><br><span class="line"></span><br><span class="line">查看類</span><br><span class="line">    -L：#顯示指定表中的規則</span><br><span class="line">    -n：#以數字格式顯示主機地址和端口號，與-L一起使用</span><br><span class="line">    -v：#顯示鏈及規則的詳細信息</span><br><span class="line">    -vv：#顯示更詳細的信息</span><br><span class="line">    -x：#顯示計數器的精確值</span><br><span class="line">    --line-numbers：#顯示規則號碼</span><br></pre></td></tr></table></figure>
<h2 id="動作（target）"><a href="#動作（target）" class="headerlink" title="動作（target）"></a>動作（target）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-j TARGET:跳轉</span><br><span class="line">    ACCEPT：#放行</span><br><span class="line">    DROP：#丟棄</span><br><span class="line">    REJECT：#拒絕</span><br><span class="line">    DNAT：#目標地址轉換</span><br><span class="line">    SNAT：#源地址轉換</span><br><span class="line">    REDIRECT：#端口重定向</span><br><span class="line">    MASQUERADE：#地址僞裝</span><br><span class="line">    LOG：#記錄日志</span><br><span class="line">    MARK：#給報文加上標記</span><br><span class="line">注：只要有允許或拒絕，是做過濾的，一定在filter表上</span><br><span class="line"></span><br><span class="line">-j SNAT：#源地址轉換</span><br><span class="line">	--to-source：#轉換成哪個源地址</span><br><span class="line">	</span><br><span class="line">-j MASQUERADE		</span><br><span class="line"><span class="meta">#</span><span class="bash">外網地址是動態獲取時用此選項，它不需要—to-source選項，可以自動查到上外網的地址。</span></span><br><span class="line"></span><br><span class="line">-j DNAT</span><br><span class="line">	--to-destination IP[:port]</span><br></pre></td></tr></table></figure>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables規則保存位置，/etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables.tus		</span><br><span class="line"><span class="meta">#</span><span class="bash">保存方法</span></span><br><span class="line">iptables-restore &lt; /etc/sysconfig/iptables.tus		</span><br><span class="line"><span class="meta">#</span><span class="bash">此爲載入方法</span></span><br></pre></td></tr></table></figure>
<h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><h2 id="查看规则"><a href="#查看规则" class="headerlink" title="查看规则"></a>查看规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">	iptables -L -n			</span><br><span class="line"><span class="meta">	#</span><span class="bash">默認顯示filter表</span></span><br><span class="line">	iptables -t filter -L -n</span><br><span class="line">	iptables -t nat -L -n</span><br><span class="line">	iptables -t mangle -L -n</span><br><span class="line"><span class="meta">	#</span><span class="bash">顯示內容中的Chain INPUT一項中沒有寫哪個表，默認就是filter表中的規則，policy表示默認策略，ACCEPT表示其爲默認值時只拒絕已知的壞蛋，如果是DROP就是只接受已知的好人。pkts表示被某一條規則所匹配到的數據包的個數，bytes表示字節數</span></span><br></pre></td></tr></table></figure>
<h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -s 172.16.0.0/16 -d 172.16.100.7 -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -A OUTPUT -s 172.16.100.7 -d 172.16.0.0/16 -p tcp --sport 22 -j ACCEPT</span><br><span class="line">yum install -y httpd vsftpd mysql-server </span><br><span class="line">service httpd start		</span><br><span class="line"><span class="meta">#</span><span class="bash">啓動服務</span></span><br><span class="line">browser測試是否可以打開ip地址</span><br><span class="line"><span class="meta">#</span><span class="bash">修改默認設置爲都不能訪問本機，之前寫的兩條可以訪問本機22端口ssh服務的規則是爲了不讓遠程連接斷開，如果先寫下面的默認規則會使遠程連接斷開，造成麻煩</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -L -n</span><br><span class="line"><span class="meta">#</span><span class="bash">允計所有外部主機訪問本機的80端口，如果web服務比ssh服務訪問量大要放在其上面，所以這裏用-I選項，默認插入在第一行。當地址爲0.0.0.0的時候可以不寫，所以這裏沒有寫-s選項</span></span><br><span class="line">iptables -I INPUT -d 172.16.100.7 -p tcp --dport 80 -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">進規則</span></span><br><span class="line">iptables -L -n		</span><br><span class="line"><span class="meta">#</span><span class="bash">查看規則</span></span><br><span class="line">iptables -L OUTPUT -s 172.16.100.7 -p tcp --sport 80 -j ACCEPT     </span><br><span class="line"><span class="meta">#</span><span class="bash">出規則</span></span><br><span class="line">echo hello &gt; /var/www/html/index.html		</span><br><span class="line"><span class="meta">#</span><span class="bash">添加默認網頁並測試</span></span><br><span class="line"><span class="meta">#</span><span class="bash">因ping請求使用的是icmp協議，所以這時是不能ping通的。因爲ping命令要先從OUTPUT鏈出去再從INPUT鏈進來，所以用本機ping 127.0.0.1也是不通的</span></span><br><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -i lo -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">-i選項是指定從哪個接口流入的請求</span></span><br><span class="line">iptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -o lo -j ACCEPT  </span><br><span class="line"><span class="meta">#</span><span class="bash">-o選項指定從哪個接口流出</span></span><br><span class="line">iptables -A OUTPUT -s 172.16.100.7 -p icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">iptables -A INPUT -d 172.16.100.7 -p icmp --icmp-type 0 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">ping別人的時候，出去的是8,進來的是0，別人ping我們的時候，進來的是8,出去的是0；這樣就可以實現我們ping外面的主機了，但別人是ping不了我們的</span></span><br></pre></td></tr></table></figure>
<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -s 172.16.0.0/16 -j DROP		</span><br><span class="line"><span class="meta">#</span><span class="bash">來自172.16.0.0/16網段的報文無論訪問本機哪個地址都被丟棄。-A表示添加一條規則</span></span><br><span class="line">iptables -t filter -A INPUT -s 172.16.0.0/16 -d 172.16.100.7  -j DROP		</span><br><span class="line"><span class="meta">#</span><span class="bash">來自172.16.0.0/16網段訪問100.7的經過INPUT鏈的都被丟棄</span></span><br><span class="line"></span><br><span class="line">iptables -t filter -A INPUT -s 172.16.0.0/16 -d 172.16.100.7 -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -A OUTPUT -s 172.16.100.7 -d 172.16.0.0/16 -p tcp --sport 22 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##這兩條命令第一條是進第二條是出，在寫規則時一定要把進出都寫上，意思是放行172.16.0.0/16網段的地址訪問172.16.100.7的22號端口ssh服務</span></span></span><br><span class="line"></span><br><span class="line">iptables -L -n -v</span><br><span class="line"><span class="meta">#</span><span class="bash">lsmod命令可以查看啓動的模塊，這裏查看iptables模塊是否啓動，四個表：iptable_mangle、iptable_nat、iptable_raw、iptable_filter</span></span><br><span class="line">modprobe -r 模塊名			</span><br><span class="line"><span class="meta">#</span><span class="bash">注銷或裝載一個模塊</span></span><br><span class="line"><span class="meta">#</span><span class="bash">iptables不是服務，但有服務腳本；服務腳本的主要作用在於管理保存規則，它保存在內核的內存空間上。可以使用lsmod查看iptables的相關模塊是否加載，啓動與停止服務就是裝載及移除iptables/netfilter相關的內核模塊。模塊一般有：iptables_nat, iptables_filter, iptables_mangle, iptables_raw, ip_nat, ip_conntrack； ip_conntrack是當我們啓用nat功能時，每一個地址轉換的相應的返回的報文是要自動管理的，要追蹤每一個地址轉換的報文的，這就是ip_conntrack的功能。</span></span><br></pre></td></tr></table></figure>
<h2 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我們是一個DNS服務器，用戶請求不是我們負責的域，我們就到互聯網找出結果；默認策略INPUT,OUTPUT,FORWARD都是DORP的話，該怎麼寫規則</span><br><span class="line"><span class="meta">#</span><span class="bash">我們是DNS服務器，應該監聽在UDP的53號端口上，當一個客戶端到我們這來請求解析的時候，我們要允許這個請求進來，源地址是客戶端，目標地址是我們的主機，目標端口是53，這應該放行；出去時原端口是53，目標地址是客戶機；但別人請求的是一個不是我們的主機負責的域時，服務器要去找根，它找根時就不是服務器端了，而是客戶端，這就要放行目標端口；當我們作爲客戶端時與這個服務器就沒關系了。這要寫四條規則，而且這只是UDP，它還要監聽在TCP上，所以一共要写八條规则。</span></span><br><span class="line"></span><br><span class="line">作爲web服務器，只開放80端口的響應與放行就可以避免決大多數的攻擊了，80端口應該是只有別人請求進來，它才響應出去。只有這樣反彈式木馬在沒有人請求時才不能響應出去。這種功能在iptables中叫連接追蹤的功能，叫ip_conntrack，這是一個內核模塊，它能時時記錄着主機上客戶端，服務器端彼此正在建立的連接關系，並能追蹤到哪一個連接與其他連接之間處於什麼狀態並有什麼關系，所以上面的情況就可以判定只允許本地主機出去的連接必須爲某一種狀態，必須處於已經建立的連接，也就是必須是對別人的響應我們才允許出去，如果不是響應是決不放行的，這就靠ip_conntrack實現，ip_conntrack可根據IP報文來追蹤TCP和UDP與ICMP的連接。它可以根據請求方與響應方處理什麼過程。在/proc/sys/net/ipv4/ip_conntrack內核文件，它是位於內存當中的，因爲它在proc系統上，這個文件保存有當前系統上每一個客戶端和當前主機與每一個其他主機所建立的連接關系 </span><br><span class="line">cat /proc/sys/net/ipv4/ip_conntrack</span><br><span class="line"><span class="meta">#</span><span class="bash">顯示內容中每條記錄兩個來回的兩個通道的信息，並保存了當前會話所處的狀態。ip_conntrack的這種功能是靠ip_conntrack模塊實現的</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用iptstate命令也可查看到這些信息</span></span><br><span class="line">iptstate -t		</span><br><span class="line"><span class="meta">#</span><span class="bash">顯示當前所有連接的個數</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/proc/sys/net/ipv4/ip_conntrack_max是設置ip_conntrack的同時追蹤的最大值，默認是32768個，超出的連接會被超時丟棄，使用戶無法連接，如果訪問量過大最好不要啓動此模塊，如果不大最好調大此項的值，這個模塊是追蹤已連接的地址的。在iptables停止的狀態下，如果執行iptables -t nat -L命令就要激活ip_conntrack和nfnetlink模塊。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">iptables重啓會清空規則，重新加載/etc/sysconfig/iptables目錄中的文件，使用命令service iptables save可以保存規則。</span></span><br><span class="line"></span><br><span class="line">保存規則：</span><br><span class="line">service iptables save		</span><br><span class="line"><span class="meta">#</span><span class="bash">保存規則</span></span><br><span class="line"><span class="meta">#</span><span class="bash">默認保存在/etc/sysconfig/iptables</span></span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables.***		</span><br><span class="line"><span class="meta">#</span><span class="bash">手動指定保存位置</span></span><br><span class="line">iptables-restore &lt; /etc/sysconfig/iptables.***		</span><br><span class="line"><span class="meta">#</span><span class="bash">因爲手動指定保存位置所以無法加載，要用此條命令指定加載位置</span></span><br></pre></td></tr></table></figure>
<h2 id="開通服務器的sshd-httpd訪問端口"><a href="#開通服務器的sshd-httpd訪問端口" class="headerlink" title="開通服務器的sshd, httpd訪問端口"></a>開通服務器的sshd, httpd訪問端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">一臺服務器，地址172.16.100.7</span><br><span class="line">iptables -F		</span><br><span class="line"><span class="meta">#</span><span class="bash">清空規則</span></span><br><span class="line">iptables -A INPUT -d 172.16.100.7 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT		</span><br><span class="line"><span class="meta">#</span><span class="bash">放行所有狀態是NEW,ESTABLISHED的訪問22號端口的連接，因爲是進來所以有NEW狀態</span></span><br><span class="line">lsmod | grep ip</span><br><span class="line">iptables -A OUTPUT -s 172.16.100.7 -p tcp --sport 22 -m state –state ESTABLISHED -j ACCEPT		</span><br><span class="line"><span class="meta">#</span><span class="bash">這是出去所有只有ESTABLISHED已連接狀態</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP		</span><br><span class="line"><span class="meta">#</span><span class="bash">改變默認策略爲不允許連接</span></span><br><span class="line">iptables -L -n		</span><br><span class="line"><span class="meta">#</span><span class="bash">查看現在的規則</span></span><br><span class="line">iptables -A INPUT -d 172.16.100.7 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -s 172.16.100.7 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">再改80端口爲相同的規則</span></span><br><span class="line">iptstate		</span><br><span class="line"><span class="meta">#</span><span class="bash">查看連接狀態</span></span><br><span class="line">sysctl -w net.ipv4.ip_conntrack_max=65536		</span><br><span class="line"><span class="meta">#</span><span class="bash">改最大值，臨時生效，要永久生效要寫在/etc/sysctl.conf中</span></span><br><span class="line">cat /proc/sys/net/ipv4/ip_conntrack_max		</span><br><span class="line"><span class="meta">#</span><span class="bash">查看 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">在/proc/sys/net/ipv4/netfilter目錄中保存了ip_conntrack的很多設置的值，其中的ip_conntrack_tcp_timeout_established中有tcp連接的保持時間，是120小時，這裏的默認單位的秒，建議將此值改小。ip_conntrack是可以追蹤三種協議tcp，udp，icmp，只是對udp，icmp只追蹤超時。</span></span><br><span class="line"></span><br><span class="line">iptables -A INPUT -d 172.16.100.7 -p icmp --icmp-type 8 -m state --state NEW,ESTABLISHED -j ACCEPT		</span><br><span class="line"><span class="meta">#</span><span class="bash">進規則</span></span><br><span class="line">iptables -A OUTPUT -s 172.16.100.7 -p icmp --icmp-type 0 -m state --state ESTABLISHED -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">出規則</span></span><br><span class="line"><span class="meta">#</span><span class="bash">寫規則時按邏輯寫，像上面兩條是允許外面的主機ping我們的主機，所以要先寫進來的規則再寫出去</span></span><br><span class="line">iptables -L -n --line-numbers		</span><br><span class="line"><span class="meta">#</span><span class="bash">查看規則，--line-numbers是顯示行號</span></span><br><span class="line">iptables -I OUTPUT -s 172.16.100.7 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">用這一條規則可以檢查所有出去的響應，也就是不用再寫其他出去的規則了，這樣雖然默認的規則是DROP，但這條規則可以規定所有出去的規則</span></span><br><span class="line">iptables -D OUTPUT 2		</span><br><span class="line"><span class="meta">#</span><span class="bash">刪除OUTPUT的第二條</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT		</span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT		</span><br><span class="line"><span class="meta">#</span><span class="bash">放行本機的回環地址，因爲ftp服務要通過本機回環地址在mysql數據庫中查詢用戶名密碼，所以要放行才能使用ftp服務或iptables對ftp服務的規則才能生效;ftp服務中PORT表示主動模式，PASV表示被動模式，要使用被動模式因端口是隨機的，所以要使用iptables狀態中的RELATED（相關聯的，與之前的命令有關系）狀態在規則中。如：</span></span><br><span class="line">iptables -A INPUT -d 172.16.100.7 -p tcp -m state --state RELATED -j ACCEPT</span><br><span class="line">iptables -R OUTPUT 1 -s 172.16.100.7 -m state --state ESTABLISHED,RELATED -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">修改OUTPUT中的第一條</span></span><br><span class="line">iptables -R INPUT 6 -d 172.16.100.7 -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">修改INPUT中的第六條，因爲第一次加這條規則時沒有指明ESTABLISHED狀態，使ftp服務連接後不能查看數據。最後，要先裝載ip_conntrack_ftp和ip_nat_ftp模塊才可進行下面的步驟，裝載方法如下：</span></span><br><span class="line">vim /etc/sysconfig/iptables-config		</span><br><span class="line"><span class="meta">#</span><span class="bash">編輯此文件</span></span><br><span class="line">	IPTABLES_MODULES="ip_nat_ftp ip_conntrack_ftp"   </span><br><span class="line">iptables -I INPUT -d 172.16.100.7 -p tcp -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">用這一條規則先來判斷連接的狀態，符合的就放行，這樣可以讓之後的規則不必再寫這兩種狀態</span></span><br><span class="line">service iptables save</span><br><span class="line">vim /etc/sysconfig/iptables		</span><br><span class="line"><span class="meta">#</span><span class="bash">直接編輯此文件來修改規則，刪除INPUT其他規則中的RELATED和ESTABLISHED</span></span><br><span class="line">service iptables reload</span><br><span class="line">iptables -L -n</span><br><span class="line">iptables -I INPUT 2 -d 172.16.100.7 -p tcp -m multiport --destination-ports 21,22,80 -m state --state NEW -j ACCEPT		</span><br><span class="line"><span class="meta">#</span><span class="bash">加入到INPUT中的第二條，只要是21,22,80端口爲NEW狀態的就放行；另外，之前所有命令中都可以用！號取反，如：</span></span><br><span class="line">    -s ！ 172.16.100.7		</span><br><span class="line">    #表示除了100.7都可以</span><br><span class="line">	</span><br><span class="line">	-j TARGET</span><br><span class="line">		LOG：記錄日志信息，log與DROP、ACCEPT使用時要放在前面</span><br><span class="line">            --log-prefix "STRING"		</span><br><span class="line">            #指定LOG日志的前綴</span><br><span class="line"><span class="meta">			#</span><span class="bash">記日志最好加上速率限定，不然記錄太多，產生大量磁盤IO,使性能下降</span></span><br><span class="line">例：</span><br><span class="line">iptables -I INPUT 4 -d 172.16.100.7 -p icmp --icmp-type 8 -j LOG --logprefix "--firewall log for icmp--"</span><br><span class="line"><span class="meta">#</span><span class="bash">記錄ping本機的日志，在日志中加上一個字符串<span class="string">"--firewall log for icmp--"</span></span></span><br></pre></td></tr></table></figure>
<h2 id="自定義規則鏈並在主鏈中被調用"><a href="#自定義規則鏈並在主鏈中被調用" class="headerlink" title="自定義規則鏈並在主鏈中被調用"></a>自定義規則鏈並在主鏈中被調用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iptables -N clean_in			</span><br><span class="line"><span class="meta">#</span><span class="bash">新建一條叫clean_in的規則鏈，其中references表示引用，也就是被主鏈調用</span></span><br><span class="line">iptables -A clean_in -d 255.255.255.255 -p icmp -j DROP         </span><br><span class="line"><span class="meta">#</span><span class="bash">添加一條規則</span></span><br><span class="line">iptables -L -n –line-numbers</span><br><span class="line">iptables -A clean_in -d 172.168.255.255 -p icmp -j DROP</span><br><span class="line">iptables -A clean_in -p tcp ! --syn -m state --state NEW -j DROP</span><br><span class="line">iptables -A clean_in -p tcp --tcp-flags ALL ALL -j DROP</span><br><span class="line">iptables -A clean_in -p tcp --tcp-flags ALL NONE -j DROP</span><br><span class="line">iptables -A clean_in -d 172.16.100.7 -j RETURN		</span><br><span class="line"><span class="meta">#</span><span class="bash">返回到主鏈上去</span></span><br><span class="line">iptables -A INPUT -d 172.16.100.7 -j clean_in</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -m multiport -p tcp --dports 53,113,135,137,139,445 -j DROP</span><br><span class="line">iptables -A INPUT -i eth0 -m multiport -p udp --dports 53,113.135.137.139.445 -j DROP</span><br><span class="line">iptables -A INPUT -i eth0 -p udp --dport 1026 -j DROP</span><br><span class="line">iptables -A INPUT -i eth0 -m multiport -p tcp --dports 1433,4899 -j DROP</span><br><span class="line">iptables -A INPUT -p icmp -m limit --limit 10/second -j ACCEPT</span><br><span class="line">iptables -I INPUT -j clean_in      </span><br><span class="line"><span class="meta">#</span><span class="bash">無論什麼地址，先交給clean_in處理一遍，clean_in如果沒有問題再返回主鏈第二條進行處理；如果要刪除自定義鏈要先刪除其中的鏈規則，再刪除自定義的鏈</span></span><br></pre></td></tr></table></figure>
<h2 id="利用iptables的recent模块来抵御DOS攻击"><a href="#利用iptables的recent模块来抵御DOS攻击" class="headerlink" title="利用iptables的recent模块来抵御DOS攻击"></a>利用iptables的recent模块来抵御DOS攻击</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ssh远程连接</span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 3 -j DROP</span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH</span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 300 --hitcount 3 --name SSH -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">利用connlimit模块将单IP的并发设置为3，会误杀使用NAT上网的用户，可以根据实际情况增大该值</span></span><br><span class="line"><span class="meta">#</span><span class="bash">利用recent和state模块限制单IP在300s内只能与本机建立3个新连接，被限制五分钟后即可恢复访问</span></span><br><span class="line">下面对最后两名做一个说明：</span><br><span class="line"><span class="meta">#</span><span class="bash">第二句是记录访问tcp22端口的新连接，记录名为SSH。--<span class="built_in">set</span>记录数据包的来源IP，如果IP已经存在将更新已经存在的条目</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第三句是指SSH记录中的IP，300s内发起超过3次连接则拒绝此IP的连接。--update是指每次建立连接都更新列表；--seconds必须与--rcheck或者--update同时使用；--hitcount必须与--rcheck或者--update同时使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">iptables的记录：/proc/net/ipt_recent/SSH</span></span><br><span class="line"><span class="meta">#</span><span class="bash">也可以使用下面的这句记录日志：</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --name SSH --second 300 --hitcount 3 -j LOG --log-prefix "SSH Attack"</span><br></pre></td></tr></table></figure>
<h2 id="测试4"><a href="#测试4" class="headerlink" title="测试4"></a>测试4</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">試驗在虛擬機中建三臺主機，一臺linux主機，一塊網卡橋接；一臺linux路由，一塊網卡橋接，地址172，一塊網卡用HOST ONLY,地址192；一臺win主機，網卡用HOST ONLY；這時linux主機可與linux路由通信，因爲都是橋接網卡；win主機也可與linux路由通信，因爲是HOST ONLY；而且兩臺主機可以ping通路由上的任一個地址，因爲路由上的兩個地址在一臺主機上，即使不在一個網段也可以通信。但linux主機不能與win主機通信，因爲沒有路由，這時改路由的/proc/sys/net/ipv4/ip_forward項爲1，那麼這臺主機就具有了路由功能。再將兩臺主機的網關指向路由的兩個IP地址，這時就能通信了，這時是用不到NAT功能的。因爲要與公網通信，私網地址不能在公網上路由，所以才用NAT；需要轉換時路由的NAT功能會自動完成，在做源地址轉換時也會做目標地址轉換，只是目標地址轉換是自動進行的</span><br></pre></td></tr></table></figure>
<h2 id="源地址转换"><a href="#源地址转换" class="headerlink" title="源地址转换"></a>源地址转换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SNAT --to-source 172.16.100.7	</span><br><span class="line"><span class="meta">#</span><span class="bash">要在nat表中創建，鏈是POSTROUTING。此条命令指對服務器來講，任何源地址是192.168.10.0/24網段的地址都轉換爲172.16.100.7。--to-source選項可指定一個地址範圍，如****-****，兩個地址間用橫線隔開來表示</span></span><br><span class="line">tcpdump -i eth0 -nn -X icmp</span><br><span class="line"><span class="meta">#</span><span class="bash">到10.7抓包</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT –to-source 123.2.3.2</span><br><span class="line"><span class="meta">#</span><span class="bash">在服務器上寫一條規則，讓所有同學可以訪問互聯網的任一網絡，公網IP地址是123.2.3.2</span></span><br></pre></td></tr></table></figure>
<h2 id="测试5"><a href="#测试5" class="headerlink" title="测试5"></a>测试5</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.10.0/24 -p icmp -j REJECT		</span><br><span class="line"><span class="meta">#</span><span class="bash">禁止192.168.10.0/24網段主機ping外網，此規則只是禁止了主機之間的ping，而沒有進入中間的防火牆服務器，所以不經過INPUT或OUTPUT進入服務器，而只是經過服務器轉發FORWARD</span></span><br></pre></td></tr></table></figure>
<h2 id="测试6"><a href="#测试6" class="headerlink" title="测试6"></a>测试6</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">如果是已建立的連接都放行</span></span><br><span class="line">iptables -A FORWARD -s 192.168.10.0/24 -p tcp --dport 80 -m state --state NEW -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">出去的規則，如果訪問的是web服務都放行，這是只能從內網出去的，外網是進不來的</span></span><br><span class="line">IPTABLES -A FORWARD -s 192.168.10.0/24 -p icmp --icmp-type 8 -m state --state NEW -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">放行ping，可以ping其他主機。這是只能從內網出去的，外網是進不來的</span></span><br><span class="line">iptables -A FORWARD -s 192.168.10.0/24 -p tcp --dport 21 -m state --state NEW -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">放行ftp服務</span></span><br><span class="line">iptables -R FORWARD 1 -m state --state ESTABLISHED,RELATED -j ACCEPT	</span><br><span class="line"><span class="meta">#</span><span class="bash">用上面兩條規則可開放ftp服務，但不要忘記在/etc/sysconfig/iptables-config中加載ip_nat_ftp和ip_nat模塊</span></span><br></pre></td></tr></table></figure>
<h2 id="目标地址转换"><a href="#目标地址转换" class="headerlink" title="目标地址转换"></a>目标地址转换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 172.16.100.7 -p tcp --dport 80 -j DNAT --to-destination 192.168.10.22		</span><br><span class="line"><span class="meta">#</span><span class="bash">目標地址轉換要在PREROUTING上做。訪問172主機80端口都以192的80端口返回結果，且只在請求80服務時才轉發</span></span><br><span class="line">iptables -t nat -R PREROUTING 1 -d 172.16.100.7 -p tcp --dport 80 -j DNAT --to-destination 192.168.10.22:8080	</span><br><span class="line"><span class="meta">#</span><span class="bash">改上一條規則，訪問172主機80端口的訪問結果都以192的8080端口返回，這就是PNAT：Port NAT 端口映射或端口轉換</span></span><br><span class="line">iptables -A FORWARD -m string --algo kmp --string "h7n9" -j DROP		</span><br><span class="line"><span class="meta">#</span><span class="bash">涉及到轉發與本機無關時一定是在FORWARD鏈上。這時沒有寫協議，所以是禁止訪問任何內容中有h7n9的</span></span><br></pre></td></tr></table></figure>
<h2 id="iptables脚本"><a href="#iptables脚本" class="headerlink" title="iptables脚本"></a>iptables脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">ipt=/usr/sbin/iptables</span><br><span class="line">einterface=eth1</span><br><span class="line">iinterface=eth0</span><br><span class="line"></span><br><span class="line">eip=172.16.100.7</span><br><span class="line">iip=192.168.10.6</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">ipt -t nat -F</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ipt -t filter -F</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ipt -t mangle -F</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">ipt -N clean_up</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ipt -A clean_up -d 255.255.255.255 -p icmp -j DROP</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ipt -A clean_up -j RETURN</span></span><br></pre></td></tr></table></figure>
<h2 id="测试7"><a href="#测试7" class="headerlink" title="测试7"></a>测试7</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j LOG --log-prefix "Denied ICMP:" --log-level 7</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">每秒只响应一次ping，超过的记录日志并丢弃</span></span><br><span class="line">iptables -A INPUT -i eth0 -p icmp --icmp-type echo-request -m statistic --mode nth --every 2 --packet 0 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">每两个<span class="built_in">echo</span>-request就丢弃一个</span></span><br></pre></td></tr></table></figure>
<h2 id="测试8"><a href="#测试8" class="headerlink" title="测试8"></a>测试8</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">不允许接受icmp数据包到本地</span></span><br><span class="line">iptables -A INPUT -p all -m state --state INVALID -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">不允许发送未知数据包到本地</span></span><br><span class="line">iptables -A INPUT all -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">允许已经允许过的连接和被动请求数据包发送到本地</span></span><br><span class="line">iptables -A INPUT -p tcp --syn --dport 22 -m state --state NEW -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">检查该连接中第一个数据包，并检查该数据包是否包含syn标记，符合两项条件才允许进入。</span></span><br><span class="line">iptables -A INPUT -p tcp --syn -m state --state NEW -m multiport --dport 21,22,23,24,25 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">使用Multiport模块一次添加多个端口</span></span><br><span class="line">iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">检查所有 TCP-Flags，但只有syn及fin两个标记同时为1时，数据包才会被筛选出来</span></span><br><span class="line">iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">检查所有 TCP-Flags中syn及fin两个标记同时为1时，数据包才会被筛选出来</span></span><br></pre></td></tr></table></figure>
<h2 id="数据指添加"><a href="#数据指添加" class="headerlink" title="数据指添加"></a>数据指添加</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /root/mac_list.txt | while read MAC</span><br><span class="line">do     </span><br><span class="line">	MAC=$( echo $MAC | awk '&#123;print $1&#125;' )      </span><br><span class="line">	iptables -t filter -A FORWARD -i eth1 -o eth0 -m mac --mac-source $MAC -j ACCEPT</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="mangle表用法-MARK模块匹配（单数据包）"><a href="#mangle表用法-MARK模块匹配（单数据包）" class="headerlink" title="mangle表用法 MARK模块匹配（单数据包）"></a>mangle表用法 MARK模块匹配（单数据包）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -A PREROUTING -p tcp --dport 80 -j MARK --set-mark 80</span><br><span class="line">iptables -A FORWARD -p all -m mark --mark 80 -j DROP</span><br></pre></td></tr></table></figure>
<h2 id="管理用户或组模块"><a href="#管理用户或组模块" class="headerlink" title="管理用户或组模块"></a>管理用户或组模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A　OUTPUT -p tcp -m owner --uid--owner tom --dport 80 -j ACCEPT</span><br><span class="line">iptables -A　OUTPUT -p udp -m owner --uid--owner tom --dport 53 -j ACCEPT</span><br><span class="line">iptables -A　OUTPUT -p all -m owner --uid--owner tom -j DROP</span><br></pre></td></tr></table></figure>
<h2 id="使用iprange模块添加ip范围"><a href="#使用iprange模块添加ip范围" class="headerlink" title="使用iprange模块添加ip范围"></a>使用iprange模块添加ip范围</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m iprange --src-range 192.168.0.2-192.168.0.61 -j DROP</span><br><span class="line">iptables -A INPUT -m iprange --dst-range 192.168.0.2-192.168.0.61 -j DROP</span><br></pre></td></tr></table></figure>
<h2 id="ttl值匹配模块"><a href="#ttl值匹配模块" class="headerlink" title="ttl值匹配模块"></a>ttl值匹配模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m ttl --ttl-eq 64 -j REJECT</span><br><span class="line"><span class="meta">#</span><span class="bash">--ttl<span class="_">-eq</span> 等于</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--ttl<span class="_">-lt</span> 小于</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--ttl<span class="_">-gt</span> 大于</span></span><br></pre></td></tr></table></figure>
<h2 id="IPSEC-SPI-值控制模块"><a href="#IPSEC-SPI-值控制模块" class="headerlink" title="IPSEC SPI 值控制模块"></a>IPSEC SPI 值控制模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p ah -m ah --ahspi 300 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p esp -m esp --espspi 200 -j ACCEPT</span><br></pre></td></tr></table></figure>
<h2 id="pkttype模块"><a href="#pkttype模块" class="headerlink" title="pkttype模块"></a>pkttype模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i eth0 -p icmp -m pkttype --pky-type broadcast -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">unicast:数据包发送的对象时特定的，如主机A传输给主机B即为unicast类型</span></span><br><span class="line"><span class="meta">#</span><span class="bash">broadcast:数据包传送的对象为广播地址，如192.168.0.255</span></span><br><span class="line"><span class="meta">#</span><span class="bash">multicast:通常应用于网络的“音频”或“视频”广播，而Multicast数据包的特点是，其Source IP一定介于224.0.0.0/24之间。</span></span><br></pre></td></tr></table></figure>
<h2 id="length模块"><a href="#length模块" class="headerlink" title="length模块"></a>length模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp -type 8 -m length --length 92 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp -type 8 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">MTU=(IP包+ICMP包+DATA)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--length 50 匹配MTU值刚好为50字节的数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--length :100 匹配MTU值小于100个字节的数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--length 50:100 匹配MTU值介于50-100个字节的数据包</span></span><br></pre></td></tr></table></figure>
<h2 id="limit数据包重复率匹配"><a href="#limit数据包重复率匹配" class="headerlink" title="limit数据包重复率匹配"></a>limit数据包重复率匹配</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -m limit --limit 6/m --limit-burst 10 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">一分钟进入10个数据包以上，就会限制一分钟进入6个数据包，直到6*10s内没有收到数据包，将会解除</span></span><br></pre></td></tr></table></figure>
<h2 id="recent模块"><a href="#recent模块" class="headerlink" title="recent模块"></a>recent模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -m recent --name icmp_db --rcheck --second 60 --hitcount 6 -j DROP</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -m recent --set --name icmp_db</span><br><span class="line">cat /proc/net/xt_recent/icmp_db</span><br><span class="line">modprobe xt_recent ip_list_tot=1024 ip_pkt_list_tot=50</span><br><span class="line"><span class="meta">#</span><span class="bash">ip_list_tot设置ip上限条数，默认100</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip_pkt_list_tot设置数据存储空间，默认20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">--name 设置跟踪数据库的文件名</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--<span class="built_in">set</span>将符合条件的来源数据添加到数据库中，但如果来源端数据已经存在，则更新数据库中的记录信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--rcheck只进行数据库中信息的匹配，并不会对已存在的数据做任何变更操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--update如果来源端的数据已存在，则将其更新；若不存在，则不做任何处理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--remove如果来源端数据已存在，则将其删除，若不存在，则不做任何处理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--seconds seconds当事件发生时，只会匹配数据库中前“几秒”内的记录，--seconds必须与--rcheck或--update参数共用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--hitcount hits匹配重复发生次数，必须与--rcheck或--update参数共用</span></span><br></pre></td></tr></table></figure>
<h2 id="string模块-匹配字符串"><a href="#string模块-匹配字符串" class="headerlink" title="string模块 匹配字符串"></a>string模块 匹配字符串</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i eth0 -o eth1 -p tcp -d $WEB_SERVER --dport 80 -m string --algo bm --string "system32" -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">--algo 字符串匹配算法的选择，string模块提供了两种不同的算法，分别是bm(Boyer-Moore)及kmp(Knuth-Pratt-Morris),其中bm算法平均速度会比kmp快，不过，你也不必太在意，因为我们匹配的对象不会太大，因此用哪种都差不多</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--from、--to设置匹配字符串的范围，我们可以使用--from来设置匹配的起点，并以--to来设置匹配的终点，其单位为字节，如--from 10意为从第10个字符串开始匹配，如果没有设置这个参数，那么匹配的范围将是整个数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--string匹配条件，如--string <span class="string">"system32"</span>是指要匹配的字符串为system32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--hex-string匹配条件，但不同于--string参数的地方在于--hex-string是以16进制的方式进行匹配，特别适合用于非ascii字符串的匹配，其匹配条件的表示方法为--hex-string <span class="string">"|2e2f303132333435|"</span>，请注意实际匹配条件为2e2f303132333435，但其左右要使用<span class="string">"|"</span>符号</span></span><br></pre></td></tr></table></figure>
<h2 id="connlimit模块-匹配连接数"><a href="#connlimit模块-匹配连接数" class="headerlink" title="connlimit模块 匹配连接数"></a>connlimit模块 匹配连接数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i eth0 -o eth1 -p tcp --syn -d $Web_Server --dport 80 -m connlimit --connlimit-above 30 --connlimit-mask 32 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--connlimit-above 指定最大连接数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--connlimit-mask 此参数为子网络掩码，用于匹配范围，例如 8A 16B 24C 25 1/2个c 32代表单一个IP</span></span><br></pre></td></tr></table></figure>
<h2 id="connbytes模块限制每个连接中所能传输的数据量"><a href="#connbytes模块限制每个连接中所能传输的数据量" class="headerlink" title="connbytes模块限制每个连接中所能传输的数据量"></a>connbytes模块限制每个连接中所能传输的数据量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -p tcp -d $Web_Server --dport 80 -m connbytes --connbytes-dir reply --connbytes-mode bytes --connbytes 20971520: -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--connbytes-dir original来源方向 reply应答方向 both双向</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--connbytes-mode packets以数据包的数量来计算 bytes以数据量来计算</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--connbytes 10:匹配10个以上的单位量 :50匹配50个一下的单位量 10:50匹配10个-50个之间的单位量</span></span><br></pre></td></tr></table></figure>
<h2 id="quota模块-匹配每个ip限制流量（不会清除纪录，要刷新纪录）"><a href="#quota模块-匹配每个ip限制流量（不会清除纪录，要刷新纪录）" class="headerlink" title="quota模块 匹配每个ip限制流量（不会清除纪录，要刷新纪录）"></a>quota模块 匹配每个ip限制流量（不会清除纪录，要刷新纪录）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i eth0 -o eth1 -p tcp --sport 80 -m quota --quota 524288000 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i eth0 -o eth1 -p tcp --sport 80 -j DROP</span><br></pre></td></tr></table></figure>
<h2 id="time模块-设置规则生效时间"><a href="#time模块-设置规则生效时间" class="headerlink" title="time模块 设置规则生效时间"></a>time模块 设置规则生效时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -o eth1 -d $SRV_FARM -m time --weekdays Mon,Tue,Wed,Thu,Fri --timestart 09:00 --timestop 21:00 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -o eth1 -d $SRV_FARM -j DROP </span><br><span class="line"><span class="meta">#</span><span class="bash">--datestart:YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--datestop</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--timestart:hh:mm[:ss]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--timestop</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--monthdays:day[,day]...1,2,3,4,5,6,7,8,9,10,31</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--weekdays:day[,day]...Mon,Tue,Wed,Thu,Fri,Sat,Sun</span></span><br></pre></td></tr></table></figure>
<h2 id="connmark模块匹配mark值（整条连接）"><a href="#connmark模块匹配mark值（整条连接）" class="headerlink" title="connmark模块匹配mark值（整条连接）"></a>connmark模块匹配mark值（整条连接）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m connmark --mark 1 -j DROP </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">conntrack模块匹配数据包状态，是state模块的加强版</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctstate:匹配数据包的状态，状态列表分别为NEW,ESTABLISHED,RELATED,INVALID,DNAT,SNAT</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctproto:用于匹配OSI七层中第四层的通信层，其功能与用法就如同iptables中的-p参数，如-p tcp,-p udp,-p 47等。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctorigsrc匹配连接发起方向的来源端IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctorigdst匹配连接发起方向的目的端IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctreplsrc匹配数据包应答方向的来源端IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctrepldst匹配数据包应答方向的目的端IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctorigsrcport</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctorigdstport</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctreplsrcport</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctrepldstport</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[!]--ctexpire连接在Netfilter Conntrack数据库(/porc/net/nf_conntrack)的存活时间，使用方法如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">匹配特定的存活时间--ctexpire time</span></span><br><span class="line"><span class="meta">#</span><span class="bash">匹配特定区间的存活时间--ctexpire time:time</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--ctdir设置要匹配那个方向的数据包，使用方法如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">只匹配连接发起方向的数据包--ctdir ORIGINAL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">只匹配数据包应答方向的数据包--ctdir REPLY</span></span><br><span class="line"><span class="meta">#</span><span class="bash">若没有设置这个参数，默认会匹配双向的所有数据包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">iptables -F</span><br><span class="line">modprobe nf_conntrack_ftp</span><br><span class="line">iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 21 -m state --state NEW -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j DROP </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">iptables -F</span><br><span class="line">modprobe nf_conntrack_ftp</span><br><span class="line">iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -m conntrack --ctproto tcp --ctorigsrc 192.168.1.0/24 --ctorigdstport 21 --ctstate NEW -j ACCEPT</span><br><span class="line">iptables -A INTPU -p tcp --dport 21 -j DROP</span><br></pre></td></tr></table></figure>
<h2 id="statistic模块进行比例匹配"><a href="#statistic模块进行比例匹配" class="headerlink" title="statistic模块进行比例匹配"></a>statistic模块进行比例匹配</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以随机方式丢弃50%的数据包</span><br><span class="line">iptables -A INPUT -p icmp -m statistic --mode random --probability 0.5 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">按一定规律在每10个icmp包中丢弃1个icmp包</span></span><br><span class="line">iptables -A INPUT -p icmp -m statistic --mode nth --every 10 -j DROP</span><br><span class="line"><span class="meta">#</span><span class="bash">--mode:random以随机方式丢弃数据包，nth按一定规律丢弃数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--probability:此参数需结合random模式使用，例如--probability 0.4 即代表丢弃40%的数据，其中的数值为0-1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--every此参数需结合nth模式使用，例如--every 10代表在每10个数据包中要丢弃1个数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--packet此参数需要在nth模式与--every参数结合使用，例如--every 10 --packet5</span></span><br></pre></td></tr></table></figure>
<h2 id="layer7-–-17"><a href="#layer7-–-17" class="headerlink" title="layer7 – 17"></a>layer7 – 17</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/27/ip命令的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/ip命令的使用/" itemprop="url">
                  ip命令的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-27 08:37:10" itemprop="dateCreated datePublished" datetime="2018-09-27T08:37:10+08:00">2018-09-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2019-05-31 13:09:09" itemprop="dateModified" datetime="2019-05-31T13:09:09+08:00">2019-05-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y iproute</span><br><span class="line">rpm -qi iproute</span><br><span class="line"><span class="meta">#</span><span class="bash">这个软件的版本与内核版本是一样的，因为它要将信息写入内核</span></span><br></pre></td></tr></table></figure>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">OBJECT := &#123; link | addr | route | netns &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">OBJECT可简写，各OBJECT的子命令也可简写；</span></span><br></pre></td></tr></table></figure>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ip  link  set - change device attributes</span><br><span class="line"><span class="meta">#</span><span class="bash">网络设备配置，<span class="built_in">set</span>是修改设备属性</span></span><br><span class="line">	dev NAME (default)：指明要管理的设备，dev关键字可省略；</span><br><span class="line">	up和down：</span><br><span class="line">	multicast on或multicast off：启用或禁用多播功能；</span><br><span class="line">	name NAME：重命名接口</span><br><span class="line">	mtu NUMBER：设置MTU的大小，默认为1500；</span><br><span class="line">	netns PID：ns为namespace，用于将接口移动到指定的网络名称空间；只能在centos7上做</span><br><span class="line">	address：改地址</span><br><span class="line">ip  link  show  - display device attributes</span><br><span class="line"><span class="meta">#</span><span class="bash">show是显示设备属性的，state是状态。显示的是二层设备属性的，与IP无关</span></span><br><span class="line">ip  link  help -  显示简要使用帮助；</span><br></pre></td></tr></table></figure>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ip link set eth1 down/up</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭或开启eth1网卡</span></span><br><span class="line">ip link set eth1 multicast off/on</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭或开启多播功能</span></span><br><span class="line">ip link set eth2 down</span><br><span class="line">ip link set eth1 name eno6668889999</span><br><span class="line"><span class="meta">#</span><span class="bash">先down掉网卡再改名，不然会报错</span></span><br><span class="line">ip netns list</span><br><span class="line"><span class="meta">#</span><span class="bash">查看网络空间名称</span></span><br><span class="line">ip link add mynet</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一个叫mynet的网络空间</span></span><br><span class="line">ip link set eno16777736 netns mynet</span><br><span class="line"><span class="meta">#</span><span class="bash">将16777736放入mynet空间</span></span><br><span class="line">ip netns exec mynet ip link show</span><br><span class="line"><span class="meta">#</span><span class="bash">这时用普通的命令是查看不到16777736网卡的，用此命令才能查看到此网卡，这像是一个虚拟机一样。这是用来创建虚拟网络的</span></span><br><span class="line">ip netns del mynet</span><br><span class="line"><span class="meta">#</span><span class="bash">删除网络空间</span></span><br></pre></td></tr></table></figure>
<h2 id="netns"><a href="#netns" class="headerlink" title="netns"></a>netns</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns：  - manage network namespaces.</span><br><span class="line">				</span><br><span class="line">ip netns list</span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有的netns</span></span><br><span class="line">ip netns add NAME</span><br><span class="line"><span class="meta">#</span><span class="bash">创建指定的netns</span></span><br><span class="line">ip netns del NAME</span><br><span class="line"><span class="meta">#</span><span class="bash">删除指定的netns</span></span><br><span class="line">ip netns exec NAME COMMAND</span><br><span class="line"><span class="meta">#</span><span class="bash">在指定的netns中运行命令</span></span><br></pre></td></tr></table></figure>
<h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ip address - protocol address management.</span><br><span class="line">					</span><br><span class="line">ip address add - add new protocol address</span><br><span class="line">ip addr add IFADDR dev IFACE</span><br><span class="line">    [label NAME]：为额外添加的地址指明接口别名；</span><br><span class="line">    [broadcast ADDRESS]：广播地址；会根据IP和NETMASK自动计算得到；</span><br><span class="line">    [scope SCOPE_VALUE]：路由的范围，主要是 link ，是与本设备有关的直接连接。</span><br><span class="line">        global：全局可用；</span><br><span class="line">        link：接口可用；</span><br><span class="line">        host：仅本机可用；</span><br><span class="line">    [proto]：此路由的路由协定，主要有 redirect, kernel, boot, static, ra 等， 其中 kernel 指的是直接由核心判断自动设定。 </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">ip address delete - delete protocol address</span><br><span class="line">ip addr  delete  IFADDR  dev  IFACE </span><br><span class="line">							</span><br><span class="line">ip address show - look at protocol addresses</span><br><span class="line">ip addr list  [IFACE]：显示接口的地址；</span><br><span class="line">						</span><br><span class="line">ip address flush - flush protocol addresses</span><br><span class="line">ip addr flush dev IFACE</span><br><span class="line"><span class="meta">#</span><span class="bash">清空接口上的所有地址</span></span><br></pre></td></tr></table></figure>
<h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有IP地址</span></span><br><span class="line">ip addr list</span><br><span class="line">ifconfig eth1 0</span><br><span class="line"><span class="meta">#</span><span class="bash">删除eth1上的地址</span></span><br><span class="line">ip addr add 192.168.1.22/24 dev eno16777736</span><br><span class="line"><span class="meta">#</span><span class="bash">添加地址，可以在一块网卡上添加多个地址，只有在一个网段的地址上才会有secondary，不同网段不会有。添加的地址用ifconfig是显示不了的，如果要显示需要加接口别名</span></span><br><span class="line">ip addr add 192.168.1.43/24 dev eno16777736 lable eno16777736:0</span><br><span class="line"><span class="meta">#</span><span class="bash">这样用ifconfig就能显示了</span></span><br><span class="line">ip link show</span><br><span class="line"><span class="meta">#</span><span class="bash">这样可以查看到地址</span></span><br><span class="line">ip addr del 192.168.1.43/24 dev eno16777736</span><br><span class="line"><span class="meta">#</span><span class="bash">删除地址</span></span><br><span class="line">ip addr flush dev eth1</span><br><span class="line"><span class="meta">#</span><span class="bash">清空eth1上的所有地址</span></span><br></pre></td></tr></table></figure>
<h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ip route - routing table management</span><br><span class="line">				</span><br><span class="line">ip route add - add new route</span><br><span class="line"><span class="meta">#</span><span class="bash">添加路由</span></span><br><span class="line">ip route change - change route</span><br><span class="line"><span class="meta">#</span><span class="bash">修改路由</span></span><br><span class="line">ip route delete - delete route</span><br><span class="line">ip  route  del  TYPE PRIFIX</span><br><span class="line"><span class="meta">#</span><span class="bash">删除路由</span></span><br><span class="line">ip route show - list routes</span><br><span class="line"><span class="meta">#</span><span class="bash">显示路由	</span></span><br><span class="line">ip route flush - flush routing tables</span><br><span class="line"><span class="meta">#</span><span class="bash">清空路由表</span></span><br><span class="line">ip route get - get a single route</span><br><span class="line">ip route get TYPE PRIFIX</span><br><span class="line"><span class="meta">#</span><span class="bash">获取单条路由</span></span><br><span class="line">ip route replace - change or add new one</span><br><span class="line"><span class="meta">#</span><span class="bash">替换路由，有老的就改老的，没有就加新的</span></span><br><span class="line">ip route add TYPE PREFIX  via GW  [dev  IFACE]  [src SOURCE_IP]</span><br><span class="line">ip route add default via GW	</span><br><span class="line"><span class="meta">#</span><span class="bash">添加默认网关</span></span><br></pre></td></tr></table></figure>
<h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ip route add 192.168.0.0/24 via 10.0.0.1 dev eth1 src 10.0.20.100</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一条到192.168.0.0/24网络的路由，（via是指明下一跳地址的）下一跳的地址是10.0.0.1，设备是eth1，源地址是10.0.20.100。（src指定源地址，源地址应该是本地网卡上的地址中的一个）也就是本机地址是10.0.20.100，如果想到达192的网络，就要通过eth1设备，走10.0.0.1这个网关。</span></span><br><span class="line">ip route delete 192.168.1.0/24</span><br><span class="line">ip route get 192.168.0.0/24</span><br><span class="line">ip route list</span><br><span class="line"><span class="meta">#</span><span class="bash">显示路由</span></span><br><span class="line">ip route add 192.168.122.0/24 via 192.168.1.10 dev eno16777736 src 192.168.1.109</span><br><span class="line"><span class="meta">#</span><span class="bash">有两个虚拟机，分别位于两台主机上，一台主机地址是192.168.1.10，一台是192.168.1.4，10主机上的虚拟机是用NAT方式联网的，地址是192.168.122.103/24；4主机上的虚拟机是桥接联网的，地址是192.168.1.109/24。现在要用109地址ssh登录192.168.122.103.添加路由，意为到192.168.122.0网络的下一跳地址是192.168.1.10，通过本机的eno16777736网卡，源地址是192.168.1.109。加完此条路由后，可以ping通192.168.122.1，但ping 192.168.122.103时显示Destination Port Unreachable。原因是在192.168.1.10的ubuntu主机上有iptables规则，用/sbin/iptables -F清除规则后，暂时解决了问题</span></span><br><span class="line">ip route add default via 172.16.0.1 dev eno16777736</span><br><span class="line"><span class="meta">#</span><span class="bash">添加默认网关</span></span><br><span class="line">ip route delete 192.168.1.0/24</span><br><span class="line"><span class="meta">#</span><span class="bash">删除到192网络的路由</span></span><br><span class="line">ip route show src 172.16.100.6</span><br><span class="line"><span class="meta">#</span><span class="bash">只显示源地址是172的路由条目</span></span><br><span class="line">ip route get 192.168.0.0/24</span><br><span class="line"><span class="meta">#</span><span class="bash">显示到192网络的路由</span></span><br><span class="line">ip route flush 10/8</span><br><span class="line"><span class="meta">#</span><span class="bash">清除10开头的网络路由，如果删除不了，就要将地址写的再详细些</span></span><br></pre></td></tr></table></figure>
<h2 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h2><h3 id="设置策略路由"><a href="#设置策略路由" class="headerlink" title="设置策略路由"></a>设置策略路由</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">问题：在某服务器上安装CentOS7.3系统，配置两个网段的IP地址，一为10.129.14.16/27，一为10.129.14.40/27。客户端使用10.129.27/27，网关10.129.14.1。使用客户端ping服务器两地址时，只能ping能10.129.14.16/27，ping10.129.14.40/27时页面停住不动，查看服务器，应该是ping包可以到达服务器，但无法返回。</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">1. 配置服务器网卡</span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-enp96s0f0</span><br><span class="line">TYPE="Ethernet"</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE="yes"</span><br><span class="line">NAME="enp96s0f0"</span><br><span class="line">UUID="5f90c86f-c21f-489e-ae8f-cf36e6eac588"</span><br><span class="line">DEVICE="enp96s0f0"</span><br><span class="line">ONBOOT="yes"</span><br><span class="line">DNS1="202.96.209.6"</span><br><span class="line">DNS2="202.96.209.133"</span><br><span class="line">IPADDR=10.129.14.16</span><br><span class="line">PREFIX=27</span><br><span class="line"><span class="meta">#</span><span class="bash">GATEWAY=10.129.14.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释网卡配置中的GATEWAY一项，多块网卡都要注释</span></span><br><span class="line"></span><br><span class="line">2. 配置策略路由表</span><br><span class="line">vim /etc/iproute2/rt_tables </span><br><span class="line">252 enp96s0f1-32</span><br><span class="line">251 enp96s0f0-0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入上面两行，前面的数字是路由表的编号，后面是自定义的表名。路由表的编号是自定义的，但linux最多可管理255个表，不要超过这个数字，另外，rt_table中原有的编号不要动，自定义的表编号也不要与原有的编号冲突。</span></span><br><span class="line"></span><br><span class="line">3. 配置策略路由</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将路由规则加入CentOS7中的/etc/rc.d/init.d/network中可以使重启网卡时路由依然生效，方法如下</span></span><br><span class="line">vim /etc/rc.d/init.d/network</span><br><span class="line">ip route flush table enp96s0f0-0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 先清空策略路由表</span></span><br><span class="line">ip route add default via 10.129.14.1 dev enp96s0f0 src 10.129.14.16 table enp96s0f0-0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一条策略路由规则，下一跳到10.129.14.1，网卡是enp96s0f0，源地址为10.129.14.16，添加到策略路由表enp96s0f0-0</span></span><br><span class="line">ip rule add from 10.129.14.16 table enp96s0f0-0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将从10.129.14.16经过的数据包都从enp96s0f0-0策略路由表中走</span></span><br><span class="line">ip route flush table enp96s0f1-32</span><br><span class="line">ip route add default via 10.129.14.33 dev enp96s0f1 src 10.129.14.40 table enp96s0f1-32</span><br><span class="line">ip rule add from 10.129.14.40 table enp96s0f1-32</span><br><span class="line"></span><br><span class="line">ip route add default via 10.129.14.1 dev enp96s0f0</span><br><span class="line"></span><br><span class="line">exit $rc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里要注意，一定要添加在最后一行的<span class="built_in">exit</span> <span class="variable">$rc</span>之上。</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart network</span><br><span class="line">ip route</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看路由，加入的默认路由生效了</span></span><br><span class="line">ip rule</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看生效的策略路由表</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后，测试的机器上也要加一条到某网段的路由，如sudo ip route add 10.129.14.32/27 via 10.129.14.1。因为默认会从无线走如果不加这条路由规则，就要将无线断开或删除这条默认路由</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时客户端就可以ping通服务器的两个ip地址了</span></span><br></pre></td></tr></table></figure>
<h3 id="查看策略"><a href="#查看策略" class="headerlink" title="查看策略"></a>查看策略</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip route show table all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有路由表</span></span><br><span class="line">ip rule</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有转发策略</span></span><br><span class="line">ip route list table eno2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个策略路由表的规则</span></span><br><span class="line">ip route list table all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示全部策略路由表</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/阿里云创建pptp-vpn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/阿里云创建pptp-vpn/" itemprop="url">
                  阿里云创建pptp_vpn
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-21 09:12:17" itemprop="dateCreated datePublished" datetime="2018-09-21T09:12:17+08:00">2018-09-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2018-11-21 10:56:12" itemprop="dateModified" datetime="2018-11-21T10:56:12+08:00">2018-11-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/阿里云/" itemprop="url" rel="index"><span itemprop="name">阿里云</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ppp pptpd</span><br></pre></td></tr></table></figure>
<h2 id="配置pptpd文件"><a href="#配置pptpd文件" class="headerlink" title="配置pptpd文件"></a>配置pptpd文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pptpd.conf</span><br><span class="line">	localip 172.17.89.106</span><br><span class="line">	remoteip 172.17.0.120-123</span><br><span class="line"><span class="meta">#</span><span class="bash">localip 172.17.89.106和remoteip 172.17.0.120-123分别是VPN的网关地址和VPN拨号获取地址段。</span></span><br><span class="line"></span><br><span class="line">vim /etc/ppp/options.pptpd</span><br><span class="line">	ms-dns 223.5.5.5</span><br><span class="line">	ms-dns 223.6.6.6</span><br><span class="line"><span class="meta">#</span><span class="bash">IP 地址 223.5.5.5 和 223.6.6.6是阿里云的公共 DNS 服务器地址，您可以根据需要调整为其它公共 DNS 服务地址。</span></span><br><span class="line"></span><br><span class="line">vim /etc/ppp/chap-secrets</span><br><span class="line">	test    *       123456     *</span><br><span class="line"><span class="meta">#</span><span class="bash">设置 pptpd 的用户名和密码。根据需要添加账号，一行只添加一个用户账号。按照 用户名 pptpd 密码 IP地址 的格式输入，每一项用空格隔开。保存后退出。示例：<span class="built_in">test</span> pptpd 123456 *，其中 * 表示所有IP。</span></span><br><span class="line"></span><br><span class="line">vim /etc/ppp/ip-up</span><br><span class="line">	ifconfig ppp0 mtu 1472</span><br><span class="line"><span class="meta">#</span><span class="bash">设置最大传输单元 MTU，在命令符 [ -x /etc/ppp/ip-up.local ] &amp;&amp; /etc/ppp/ip-up.local “<span class="variable">$@</span>” 下面添加 ifconfig ppp0 mtu 1472。</span></span><br></pre></td></tr></table></figure>
<h2 id="修改内核参数"><a href="#修改内核参数" class="headerlink" title="修改内核参数"></a>修改内核参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">	net.ipv4.ip_forward = 1</span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="meta">#</span><span class="bash">临时生效</span></span><br></pre></td></tr></table></figure>
<h2 id="添加防火墙规则"><a href="#添加防火墙规则" class="headerlink" title="添加防火墙规则"></a>添加防火墙规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/255.255.255.0 -j SNAT --to-source 123.127.82.11</span><br><span class="line"><span class="meta">#</span><span class="bash">添加 NAT 转发规则，其中123.127.82.11为您的实例公网 IP 地址</span></span><br><span class="line">iptables-save</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start pptpd</span><br><span class="line">systemctl enable pptpd</span><br></pre></td></tr></table></figure>
<h1 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ppp pptp pptp-setup</span><br></pre></td></tr></table></figure>
<h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pptpsetup --create test --server 123.127.82.11 --username test --password 123456 --encrypt --start</span><br><span class="line"><span class="meta">#</span><span class="bash">创建后会自动连接</span></span><br><span class="line">vim /etc/ppp/options.pptpd</span><br><span class="line">	require-mppe-128</span><br><span class="line"><span class="meta">#</span><span class="bash">如果有报错，要加入这一行。</span></span><br></pre></td></tr></table></figure>
<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 实际情况，因为测试发现连接VPN后，可以连接kafka，但硬件设备不能向netty发送数据。但不连接VPN时，硬件设备可以向netty发送数据，但连接不上阿里云的kafka。判断认为，这是由于使用了阿里云提供的添加路由的方法，替换了默认网关。所以有此现象。重新调整了添加路由的命令如下</span><br><span class="line">ip route add 172.17.0.0/16 via 172.17.89.106 dev ppp0</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一条路由，到172.17.0.0/16网络，下一跳地址是172.17.89.106，设备是ppp0。使用via指定下一跳地址。</span></span><br><span class="line">* 阿里云方法，实际中这样是不行的</span><br><span class="line">ip route replace default dev ppp0</span><br><span class="line"><span class="meta">#</span><span class="bash">测试发现，要先连接VPN，再添加路由。如果VPN断开，要重新添加路由。添加后会有三条信息加入，如下第一条和最后两条</span></span><br><span class="line">[root@bogon ~]# ip route l</span><br><span class="line">default dev ppp0 scope link </span><br><span class="line">default via 10.5.5.1 dev ens160 proto static metric 100 </span><br><span class="line">10.5.5.0/24 dev ens160 proto kernel scope link src 10.5.5.25 metric 100 </span><br><span class="line">113.52.7.78 via 10.5.5.1 dev ens160 src 10.5.5.25 </span><br><span class="line">172.17.89.106 dev ppp0 proto kernel scope link src 172.17.0.120</span><br></pre></td></tr></table></figure>
<h2 id="添加命令"><a href="#添加命令" class="headerlink" title="添加命令"></a>添加命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/ppp-2.4.5/scripts/pon /usr/sbin</span><br><span class="line">cp /usr/share/doc/ppp-2.4.5/scripts/poff /usr/sbin</span><br><span class="line">chmod +x /usr/sbin/pon /usr/sbin/poff</span><br></pre></td></tr></table></figure>
<h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pon test</span><br><span class="line"><span class="meta">#</span><span class="bash">连接vpn</span></span><br><span class="line">poff test</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭vpn连接</span></span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://help.aliyun.com/knowledge_detail/41345.html?spm=5176.11065259.1996646101.searchclickresult.7c0b72c0WCltyE&amp;accounttraceid=1de748fe-9665-48c9-972a-021e6cfdf811#CentOSVPNclient" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/41345.html?spm=5176.11065259.1996646101.searchclickresult.7c0b72c0WCltyE&amp;accounttraceid=1de748fe-9665-48c9-972a-021e6cfdf811#CentOSVPNclient</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/docker使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/docker使用/" itemprop="url">
                  docker使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-20 14:26:06" itemprop="dateCreated datePublished" datetime="2018-09-20T14:26:06+08:00">2018-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2019-04-12 11:21:01" itemprop="dateModified" datetime="2019-04-12T11:21:01+08:00">2019-04-12</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Container/" itemprop="url" rel="index"><span itemprop="name">Container</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本运行方式"><a href="#基本运行方式" class="headerlink" title="基本运行方式"></a>基本运行方式</h1><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker search centos</span><br><span class="line"><span class="meta">#</span><span class="bash">搜索centos镜像</span></span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   4726                [OK]                </span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              118                                     [OK]</span><br><span class="line">jdeathe/centos-ssh                 CentOS-6 6.10 x86_64 / CentOS-7 7.5.1804 x86…   99                                      [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with "headless" VNC session…   63                                      [OK]</span><br><span class="line">imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              45                                      [OK]</span><br></pre></td></tr></table></figure>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull guyton/centos6</span><br><span class="line"><span class="meta">#</span><span class="bash">下载guyton/centos6镜像，官方没有普通的centos6镜像</span></span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it guyton/centos6 bash</span><br><span class="line"><span class="meta">#</span><span class="bash">这是最简单的运行方式。此命令可以运行多次，每运行一次，就是创建一个新的容器。选项功能如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-i：交互式操作；-t：终端。我们这里打算进入bash执行一些命令并查看返回结果，因此我们需要交互式终端。bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。</span></span><br></pre></td></tr></table></figure>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* 查看正在运行的容器</span><br><span class="line">docker@boot2docker:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">1cd2b28b4f21        guyton/centos6      "bash"              24 seconds ago      Up 23 seconds                           zen_lamarr</span><br><span class="line">418cbf256f89        guyton/centos6      "bash"              5 minutes ago       Up 5 minutes                            sad_haibt</span><br><span class="line"><span class="meta">#</span><span class="bash">因为运行了两次docker run -it guyton/centos6 bash，所以这里有两个容器</span></span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="meta">#</span><span class="bash">标题含义：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">CONTAINER ID:容器的唯一表示ID。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">IMAGE:创建容器时使用的镜像。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">COMMAND:容器最后运行的命令。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">CREATED:创建容器的时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">STATUS:容器状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">PORTS:对外开放的端口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">NAMES:容器名。可以和容器ID一样唯一标识容器，同一台宿主机上不允许有同名容器存在，否则会冲突。</span></span><br><span class="line">=======================================================================================</span><br><span class="line">* 查看所有容器</span><br><span class="line">docker@boot2docker:~$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">1cd2b28b4f21        guyton/centos6      "bash"              2 minutes ago       Exited (0) 8 seconds ago                       zen_lamarr</span><br><span class="line">f2da3e7678a4        guyton/centos6      "bash"              4 minutes ago       Exited (0) 2 minutes ago                       festive_davinci</span><br><span class="line">418cbf256f89        guyton/centos6      "bash"              7 minutes ago       Up 7 minutes                                   sad_haibt</span><br><span class="line"><span class="meta">#</span><span class="bash">可从STATUS列看出只有一个运行，另外两个已停止</span></span><br><span class="line"></span><br><span class="line">* 查看最新创建的容器，只列出最后创建的</span><br><span class="line">docker@boot2docker:~$ docker ps -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">1cd2b28b4f21        guyton/centos6      "bash"              5 minutes ago       Exited (0) 3 minutes ago                       zen_lamarr</span><br><span class="line"></span><br><span class="line">* 列出最后创建的x个容器</span><br><span class="line">docker@boot2docker:~$ docker ps -n=2</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">1cd2b28b4f21        guyton/centos6      "bash"              6 minutes ago       Exited (0) 4 minutes ago                       zen_lamarr</span><br><span class="line">f2da3e7678a4        guyton/centos6      "bash"              8 minutes ago       Exited (0) 6 minutes ago                       festive_davinci</span><br><span class="line"><span class="meta">#</span><span class="bash">:-n=x选项，会列出最后创建的x个容器</span></span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* 语法：</span><br><span class="line">docker start docker_name</span><br><span class="line">docker start docker_ID</span><br><span class="line"></span><br><span class="line">* 例：</span><br><span class="line">docker@boot2docker:~$ docker start f2da3e7678a4</span><br><span class="line">f2da3e7678a4</span><br><span class="line">docker@boot2docker:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f2da3e7678a4        guyton/centos6      "bash"              10 minutes ago      Up 2 seconds                            festive_davinci</span><br><span class="line">418cbf256f89        guyton/centos6      "bash"              14 minutes ago      Up 13 minutes                           sad_haibt</span><br><span class="line">docker@boot2docker:~$ docker start zen_lamarr</span><br><span class="line">zen_lamarr</span><br><span class="line">docker@boot2docker:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">1cd2b28b4f21        guyton/centos6      "bash"              9 minutes ago       Up 4 seconds                            zen_lamarr</span><br><span class="line">f2da3e7678a4        guyton/centos6      "bash"              11 minutes ago      Up About a minute                       festive_davinci</span><br><span class="line">418cbf256f89        guyton/centos6      "bash"              15 minutes ago      Up 15 minutes                           sad_haibt</span><br><span class="line"><span class="meta">#</span><span class="bash">第一个是通过ID启动的，第二个通过name启动</span></span><br></pre></td></tr></table></figure>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 语法：</span><br><span class="line">docker stop [NAME]/[CONTAINER ID]:将容器退出。</span><br><span class="line">docker kill [NAME]/[CONTAINER ID]:强制停止一个容器。</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 语法</span><br><span class="line">docker rm [NAME]/[CONTAINER ID]:不能够删除一个正在运行的容器，会报错。需要先停止容器。</span><br><span class="line"></span><br><span class="line">* 例：</span><br><span class="line">docker rm 'docker ps -a -q'</span><br><span class="line"><span class="meta">#</span><span class="bash">-a标志列出所有容器，-q标志只列出容器的ID，然后传递给rm命令，依次删除容器。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">一次性删除：docker本身没有提供一次性删除操作，但是可以使用如上命令实现</span></span><br></pre></td></tr></table></figure>
<h2 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker@boot2docker:~$ docker attach 1cd2b28b4f21</span><br><span class="line"><span class="meta">#</span><span class="bash">使用attach通过ID进入docker</span></span><br><span class="line"></span><br><span class="line">docker@boot2docker:~$ docker exec -it f2da3e7678a4 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">使用<span class="built_in">exec</span>参数进入</span></span><br></pre></td></tr></table></figure>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. exit（命令）：退出后，这个容器也就消失了，容器销毁ps查不到</span><br><span class="line">2. Ctrl+D（快捷方式）：退出后，这个容器也就消失了,容器销毁ps查不到	</span><br><span class="line">3. 先按Ctrl+P;再按Ctrl+Q（快捷方式）：退出容器，ps能查到，还在后台运行</span><br></pre></td></tr></table></figure>
<h2 id="端口暴露"><a href="#端口暴露" class="headerlink" title="端口暴露"></a>端口暴露</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp</span><br><span class="line"><span class="meta">#</span><span class="bash">docker自动在host上打开49000到49900的端口，映射到容器（由镜像指定，或者--expose参数指定）的暴露端口</span></span><br><span class="line">docker run -d -p 5000:80 training/webapp</span><br><span class="line"><span class="meta">#</span><span class="bash">host上5000号端口，映射到容器暴露的80端口</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:80 training/webapp</span><br><span class="line"><span class="meta">#</span><span class="bash">host上127.0.0.1:5000号端口，映射到容器暴露的80端口</span></span><br><span class="line">docker run -d -p 127.0.0.1::5000 training/webapp</span><br><span class="line"><span class="meta">#</span><span class="bash">host上127.0.0.1:随机端口，映射到容器暴露的80端口</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp</span><br><span class="line"><span class="meta">#</span><span class="bash">绑定udp端口</span></span><br><span class="line">docker run -it --privileged --name test --hostname test -p 8080:80 centos</span><br><span class="line"><span class="meta">#</span><span class="bash">测试发现，在创建时要使用-it选项，不然之后使用docker start 命令是不能启动容器的，原因待查。--name指定容器名，--hostname指定容器内的主机名</span></span><br><span class="line">=======================================================================================</span><br><span class="line">docker run选项：</span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">  -a, --attach=[]            登录容器（以docker run -d启动的容器）</span><br><span class="line">  -c, --cpu-shares=0         设置容器CPU权重，在CPU共享场景使用</span><br><span class="line">  --cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">  --cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">  --cidfile=""               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span><br><span class="line">  --cpuset=""                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span><br><span class="line">  -d, --detach=false         指定容器运行于前台还是后台，-d表示在后台运行</span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通</span><br><span class="line">  --dns=[]                   指定容器的dns服务器</span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量</span><br><span class="line">  --entrypoint=""            覆盖image的入口点</span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量</span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口</span><br><span class="line">  -h, --hostname=""          指定容器的主机名</span><br><span class="line">  -i, --interactive=false    打开STDIN，用于控制台交互</span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息</span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用</span><br><span class="line">  -m, --memory=""            指定容器的内存上限</span><br><span class="line">  --name=""                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span><br><span class="line">  --net="bridge"             容器网络设置，待详述</span><br><span class="line">  -P, --publish-all=false    指定容器暴露的端口，待详述</span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口，待详述</span><br><span class="line">  --privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line">  --restart=""               指定容器停止后的重启策略，待详述</span><br><span class="line">  --rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span><br><span class="line">  --sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span><br><span class="line">  -t, --tty=false            分配tty设备，该可以支持终端登录</span><br><span class="line">  -u, --user=""              指定容器的用户</span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录</span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录</span><br><span class="line">  -w, --workdir=""           指定容器的工作目录</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx1 -p 8081:80 -itd nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">创建容器，暴露端口。之后可以通过192.168.99.100:8081访问nginx测试页</span></span><br><span class="line">docker exec -it nginx1 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">进入nginx1容器中</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/docker学习三：使用镜像/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/docker学习三：使用镜像/" itemprop="url">
                  docker学习三：使用镜像
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-20 14:26:06" itemprop="dateCreated datePublished" datetime="2018-09-20T14:26:06+08:00">2018-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2019-02-02 14:17:02" itemprop="dateModified" datetime="2019-02-02T14:17:02+08:00">2019-02-02</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Container/" itemprop="url" rel="index"><span itemprop="name">Container</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 命令格式</span><br><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 具体的选项可以通过docker pull --<span class="built_in">help</span>命令看到</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Docker 镜像仓库地址：地址的格式一般是&lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仓库名：这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub,如果不给出用户名，则默认为library，也就是官方镜像。</span></span><br><span class="line"></span><br><span class="line">* 例：</span><br><span class="line">root@test:~# docker pull ubuntu:16.04</span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">18d680d61657: Pull complete </span><br><span class="line">0addb6fece63: Pull complete </span><br><span class="line">78e58219b215: Pull complete </span><br><span class="line">eb6959a66df2: Pull complete </span><br><span class="line">Digest: sha256:76702ec53c5e7771ba3f2c4f6152c3796c142af2b3cb1a02fce66c697db24f12</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是ubuntu:16.04，因此将会获取官方镜像library/ubuntu仓库中标签为16.04的镜像。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<font color="red">从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的sha256的摘要，以确保下载一致性。层 ID 以及<br>sha256<br>的摘要不总是一样的。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</font>
</blockquote>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker run -it --rm ubuntu:16.04 bash</span><br><span class="line">root@82e7f3542e12:/# cat /etc/os-release </span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="16.04.5 LTS (Xenial Xerus)"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 16.04.5 LTS"</span><br><span class="line">VERSION_ID="16.04"</span><br><span class="line">HOME_URL="http://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="http://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以上面的ubuntu:16.04为基础，使用上面命令进行交互式操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run是运行容器的命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -it：这是两个参数，一个是-i：交互式操作；一个是-t：终端。我们这里打算进入bash执行一些命令并查看返回结果，因此我们需要交互式终端。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动docker rm。我们这里只是随便执行个命令，看看结果，因此使用--rm可以避免浪费空间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ubuntu:16.04：这是指用ubuntu:16.04镜像为基础来启动容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bash：放在镜像名后的是命令，这里我们希望有个交互式shell，因此用的是bash。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是Ubuntu 16.04.4 LTS系统。最后我们通过<span class="built_in">exit</span>退出了这个容器。</span></span><br></pre></td></tr></table></figure>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               4a689991aa24        4 weeks ago         116MB</span><br><span class="line">ubuntu              latest              4a689991aa24        4 weeks ago         116MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</span><br><span class="line"><span class="meta">#</span><span class="bash"> image ls可以替换为images，也就是docker images，显示的效果与上面的命令相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出已经下载下来的镜像。列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到ubuntu:latest和ubuntu:16.04拥有相同的 ID，因为它们对应的是同一个镜像。</span></span><br></pre></td></tr></table></figure>
<h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><blockquote>
<font color="red">如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:16.04<br>镜像大小，在这里是<br>116MB，但是在 Docker Hub 显示的却是<br>50<br>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而<br>docker image ls<br>显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。另外一个需要注意的问题是，<br>docker image ls<br>列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 </font>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   1                   116MB               116MB (99%)</span><br><span class="line">Containers          2                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用此命令可以便捷的查看镜像、容器、数据卷所占用的空间。</span></span><br></pre></td></tr></table></figure>
<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;				&lt;none&gt;				00285df0df87		5 days ago			342 MB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docker image ls命令查看时，可能会出现上面的结果。这个镜像既没有仓库名，也没有标签，均为&lt;none&gt;。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个镜像原本是有镜像名和标签的，随着官方镜像维护，发布新版本后，重新执行<span class="string">"docker pull 镜像名"</span>命令时，这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了&lt;none&gt;。除了docker pull命令可能导致这种情况，docker build命令也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取走，从而出现仓库名、标签均为&lt;none&gt;的镜像。这类无标签镜像也被称为虚悬镜像(dangling image)</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls -f dangling=true</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;				&lt;none&gt;				00285df0df87		5 days ago			342 MB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用上面命令可以显示出虚悬镜像。一般虚悬镜像已经没有了存在的价值，可以随意删除。</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image prune </span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line">Total reclaimed space: 0B</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的虚悬镜像</span></span><br></pre></td></tr></table></figure>
<h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><blockquote>
<font color="red">为了加速镜像构建、重复利用资源，Docker 会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的docker image ls列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加-a参数。</font>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker image ls -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</span></span><br></pre></td></tr></table></figure>
<h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               4a689991aa24        4 weeks ago         116MB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据仓库名列出镜像</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls ubuntu:16.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               4a689991aa24        4 weeks ago         116MB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定仓库名和标签，列出特定的某个镜像</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls -f since=ubuntu:16.04</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤器参数--filter，或者简写为-f。查询在ubuntu:16.04之后建立的镜像。</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls -f before=ubuntu:16.04</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将since改为before，可以查询在ubuntu:16.04之前建立的镜像。</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls -f label=com.example.version=0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果镜像构建时，定义了LABEL，还可以通过LABEL来过滤。</span></span><br></pre></td></tr></table></figure>
<h4 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker image ls -q</span><br><span class="line">4a689991aa24</span><br><span class="line">4ab4c602aa5e</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，docker image ls会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用docker image ls把所有的虚悬镜像的 ID 列出来，然后才可以交给docker image rm命令作为参数来删除指定的这些镜像，这个时候就用到了-q参数。--filter配合-q产生出指定范围的 ID 列表，然后送给另一个docker命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span><br><span class="line">4a689991aa24: ubuntu</span><br><span class="line">4ab4c602aa5e: hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。上面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名</span></span><br><span class="line"></span><br><span class="line">root@test:~# docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">4a689991aa24        ubuntu              16.04</span><br><span class="line">4ab4c602aa5e        hello-world         latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以表格等距显示，并且有标题行，和默认一样，不过列为自定义</span></span><br></pre></td></tr></table></figure>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 命令格式</span><br><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除镜像</span></span><br><span class="line"></span><br><span class="line">docker rm &lt;containerID&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br></pre></td></tr></table></figure>
<h4 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">* 使用ID删除镜像</span><br><span class="line">root@test:~# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               4a689991aa24        4 weeks ago         116MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</span><br><span class="line">root@test:~# docker image rm 4ab</span><br><span class="line">Error response from daemon: conflict: unable to delete 4ab4c602aa5e (must be forced) - image is being used by stopped container 641b04116b0a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以通过镜像的ID号删除镜像，并且ID号可以只使用前几位。但上面删除时有报错，说明有容器在依赖此镜像，需要先停止这个容器才能删除镜像。</span></span><br><span class="line">root@test:~# docker rm 641b04116b0a</span><br><span class="line">641b04116b0a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line">root@test:~# docker image rm 4ab</span><br><span class="line">Error response from daemon: conflict: unable to delete 4ab4c602aa5e (must be forced) - image is being used by stopped container 41a0dff7c649</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次删除镜像时依然有此报错，但这次容器的ID变了</span></span><br><span class="line">root@test:~# docker rm 41a0dff7c649</span><br><span class="line">41a0dff7c649</span><br><span class="line">root@test:~# docker image rm 4ab   </span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Deleted: sha256:4ab4c602aa5eed5528a6620ff18a1dc4faef0e1ab3a5eddeddb410714478c67f</span><br><span class="line">Deleted: sha256:428c97da766c4c13b19088a471de6b622b038f3ae8efa10ec5a37d6d31a2df0b</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次删除容器后就可以删除镜像了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以用镜像的完整 ID，也称为长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用短 ID来删除镜像。docker image ls默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</span></span><br><span class="line"></span><br><span class="line">* 使用镜像名删除镜像</span><br><span class="line">root@test:~# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               4a689991aa24        4 weeks ago         116MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        2 months ago        1.84kB</span><br><span class="line">root@test:~# docker image rm hello-world</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Deleted: sha256:4ab4c602aa5eed5528a6620ff18a1dc4faef0e1ab3a5eddeddb410714478c67f</span><br><span class="line">Deleted: sha256:428c97da766c4c13b19088a471de6b622b038f3ae8efa10ec5a37d6d31a2df0b</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用镜像名，也就是&lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</span></span><br><span class="line"></span><br><span class="line">* 使用镜像摘要删除镜像</span><br><span class="line">root@test:~# docker image ls --digests </span><br><span class="line">REPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               sha256:76702ec53c5e7771ba3f2c4f6152c3796c142af2b3cb1a02fce66c697db24f12   4a689991aa24        4 weeks ago         116MB</span><br><span class="line">hello-world         latest              sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788   4ab4c602aa5e        2 months ago        1.84kB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询镜像摘要</span></span><br><span class="line">root@test:~# docker image rm node@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Error: No such image: node@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按镜像摘要删除镜像，但测试失败，提示没有这个镜像</span></span><br><span class="line"></span><br><span class="line">* Untagged 和 Deleted</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是Untagged，另一类是Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的Untagged的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么Delete行为就不会发生。所以并非所有的docker image rm都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己docker pull看到的层数不一样的原因。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在(即使容器没有运行)，那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖，那么删除必然会导致故障。如果这些是容器不需要的，应该先将它们删除，然后再来删除镜像。</span></span><br></pre></td></tr></table></figure>
<h4 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有仓库名为redis的镜像。$()表示输入结果，同``。</span></span><br><span class="line">docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有在mongo:3.2之前创建的镜像</span></span><br></pre></td></tr></table></figure>
<h4 id="CentOS-RHEL-的用户需要注意的事项"><a href="#CentOS-RHEL-的用户需要注意的事项" class="headerlink" title="CentOS/RHEL 的用户需要注意的事项"></a>CentOS/RHEL 的用户需要注意的事项</h4><blockquote>
<p>在 Ubuntu/Debian 上有UnionFS可以使用，如aufs或者overlay2，而 CentOS 和 RHEL的内核中没有相关驱动。因此对于这类系统，一般使用devicemapper驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择devicemapper，但是为了简化配置，其devicemapper是跑在一个稀疏文件模拟的块设备上，也被称为loop-lvm。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是loop-lvm的做法非常不好，其稳定性、性能更差，无论是日志还是docker info中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给devicemapper驱动做存储层的做法，这类做法也被称为配置direct-lvm。<br>除了前面说到的问题外，devicemapper+loop-lvm还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到/var/lib/docker/devicemapper/devicemapper/data不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。<br>所以对于 CentOS/RHEL 的用户来说，在没有办法使用UnionFS的情况下，一定要配置direct-lvm给devicemapper，无论是为了性能、稳定性还是空间利用率。<br>或许有人注意到了 CentOS 7 中存在被 backports 回来的overlay驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</p>
</blockquote>
<h3 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h3><blockquote>
<p>注意：docker commit命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用docker commit定制镜像，定制镜像应该使用Dockerfile来完成。</p>
<p>镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。<br>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。<br>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">root@ruopu:~# docker pull nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载nginx镜像</span></span><br><span class="line">root@ruopu:~# docker run --name webserver -d -p 80:80 nginx</span><br><span class="line">4fc2b542c0dee4c38cbc1f93c1dd3191f2742f0a58e7724770528e93895b923d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用nginx镜像启动一个容器，命名为webserver，并且映射了 80 端口，-d表示让容器在后台运行，这样我们就可以用浏览器去访问这个nginx服务器了。</span></span><br><span class="line">root@ruopu:~# curl localhost</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用本机访问或使用浏览器访问IP地址。</span></span><br><span class="line">root@ruopu:~# docker exec -it webserver bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docker <span class="built_in">exec</span>命令进入容器，-i：交互式操作，-t：终端。进入容器使用bash执行一些命令</span></span><br><span class="line">root@4fc2b542c0de:/# echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改默认网页内容</span></span><br><span class="line">root@4fc2b542c0de:/# exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit</span><br><span class="line">root@ruopu:~# curl localhost</span><br><span class="line">root@ruopu:~# docker diff webserver </span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">C /usr</span><br><span class="line">C /usr/share</span><br><span class="line">C /usr/share/nginx</span><br><span class="line">C /usr/share/nginx/html</span><br><span class="line">C /usr/share/nginx/html/index.html</span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里修改了容器的文件，也就是改动了容器的存储层。我们可以通过docker diff命令看到具体的改动。</span></span><br><span class="line">============================================================================================</span><br><span class="line">* 当我们运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个docker commit命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</span><br><span class="line">* 语法</span><br><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br><span class="line">============================================================================================</span><br><span class="line">root@ruopu:~# docker commit --author "ruopu &lt;ruopu@ccgoldenet.com&gt;" --message "修改了默认网页" webserver nginx:v2</span><br><span class="line">sha256:c3ceec8361f57f2dd49657b42ea808b9062a7a73f6327e5675be3ad8c704055a</span><br><span class="line"><span class="meta">#</span><span class="bash"> --author是指定修改的作者，--message是记录本次修改的内容。这点和git版本控制相似，不过这里这些信息可以省略留空。</span></span><br><span class="line">root@ruopu:~# docker image ls nginx</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">nginx               v2                  c3ceec8361f5        About a minute ago   109MB</span><br><span class="line">nginx               latest              e81eb098537d        4 days ago           109MB</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以在docker image ls中看到这个新定制的镜像</span></span><br><span class="line">root@ruopu:~# docker history nginx:v2 </span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">c3ceec8361f5        2 minutes ago       nginx -g daemon off;                            97B                 修改了默认网页</span><br><span class="line">e81eb098537d        4 days ago          /bin/sh -c #(nop)  CMD ["nginx" "-g" "daemon…   0B                  </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c #(nop)  STOPSIGNAL [SIGTERM]         0B                  </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c #(nop)  EXPOSE 80/tcp                0B                  </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c ln -sf /dev/stdout /var/log/nginx…   22B                 </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c set -x  &amp;&amp; apt-get update  &amp;&amp; apt…   53.8MB              </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c #(nop)  ENV NJS_VERSION=1.15.6.0.…   0B                  </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c #(nop)  ENV NGINX_VERSION=1.15.6-…   0B                  </span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B                  </span><br><span class="line">&lt;missing&gt;           5 days ago          /bin/sh -c #(nop)  CMD ["bash"]                 0B                  </span><br><span class="line">&lt;missing&gt;           5 days ago          /bin/sh -c #(nop) ADD file:dab9baf938799c515…   55.3MB </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用docker <span class="built_in">history</span>具体查看镜像内的历史记录，如果比较nginx:latest的历史记录，我们会发现新增了我们刚刚提交的这一层。</span></span><br><span class="line">root@ruopu:~# docker run --name web2 -d -p 81:80 nginx:v2</span><br><span class="line">54b6e4618182e413ea4a8873228f743b535667a2421035c46271514ddea7cad3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用新定制的镜像运行一个新容器，我们命名为新的服务为web2，并且映射到81端口</span></span><br><span class="line">root@ruopu:~# curl localhost:81</span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问新容器，也可以访问IP:81</span></span><br></pre></td></tr></table></figure>
<h4 id="慎用docker-commit"><a href="#慎用docker-commit" class="headerlink" title="慎用docker commit"></a>慎用docker commit</h4><blockquote>
<p>实际环境一般不会使用上面的方法定制新的镜像。如果仔细观察之前的docker diff webserver的结果，你会发现除了真正想要修改的/usr/share/nginx/html/index.html文件外，由于命令的执行，还有很多文件被改动或添加了。如果进行更多的变动，会导致镜像非常臃肿。</p>
<p>此外，使用docker commit意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令，怎么生成的镜像，别人根本无从得知。虽然docker diff或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。</p>
<p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用docker commit制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
</blockquote>
<h3 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h3><blockquote>
<p>从刚才的docker commit的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。<br>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ruopu:~# mkdir mynginx</span><br><span class="line">root@ruopu:~# cd mynginx/</span><br><span class="line">root@ruopu:~/mynginx# touch Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在一个空白目录中，建立一个文本文件，并命名为Dockerfile</span></span><br><span class="line">root@ruopu:~/mynginx# vim Dockerfile </span><br><span class="line">    FROM nginx</span><br><span class="line">    RUN echo '&lt;h1&gt;Hello,Docker!!!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM和RUN</span></span><br></pre></td></tr></table></figure>
<h4 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h4><blockquote>
<font color="red">所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个nginx镜像的容器，再进行修改一样，基础镜像是必须指定的。而FROM就是指定基础镜像，因此一个Dockerfile中FROM是必备的指令，并且必须是第一条指令。</font>

<p>Docker Store中有服务类镜像与基础操作系统镜像可供下载。除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> FROM scratch</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>如果你以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接FROM scratch会让镜像体积更加小巧。使用 Go 语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go是特别适合容器微服务架构的语言的原因之一。</p>
</blockquote>
<h4 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h4><blockquote>
<p>RUN指令是用来执行命令行命令的。由于命令行的强大能力，RUN指令在定制镜像时是最常用的指令之一。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">============================================================================================</span><br><span class="line">* 格式一</span><br><span class="line">shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的RUN指令就是这种格式。</span><br><span class="line">	RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">* 格式二</span><br><span class="line">exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。</span><br><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile 中每一个指令都会建立一层，RUN也不例外。每一个RUN的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit这一层的修改，构成新的镜像。也就是说，每一个RUN命令都会创建一层镜像，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过127 层。</span></span><br><span class="line">============================================================================================</span><br><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps='gcc libc6-dev make' \	</span><br><span class="line"><span class="meta">#</span><span class="bash">设置变量这一步很重要，如果不定义，下面的yum安装时将无法进行，yum会将其后面的命令都当作安装的包</span></span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要写成上面的样子，不能每行前面都加一个RUN命令。所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个RUN来一一对应不同的命令，而是仅仅使用一个RUN指令，并使用&amp;&amp;将各个所需命令串联起来。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /var/lib/apt/lists/下是apt的缓存文件。apt-get purge 命令可以将包和配置文件一起删除，--auto-remove可以自动删除所有未使用的包。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make命令的-C选项：指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/<span class="built_in">test</span> –C prog”等价于“make –C ~hchen/<span class="built_in">test</span>/prog”。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加\的命令换行方式，以及行首<span class="comment">#进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，,这是一个比较好的习惯。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了apt缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span></span><br></pre></td></tr></table></figure>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">============================================================================================</span><br><span class="line">* 语法</span><br><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br><span class="line">============================================================================================</span><br><span class="line">root@ruopu:~# cd /root/mynginx/</span><br><span class="line">root@ruopu:~/mynginx# docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> e81eb098537d</span></span><br><span class="line">Step 2/2 : RUN echo '&lt;h1&gt;Hello,Docker!!!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> fdbbe8c89936</span></span><br><span class="line">Removing intermediate container fdbbe8c89936</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> b6eed855d34f</span></span><br><span class="line">Successfully built b6eed855d34f</span><br><span class="line">Successfully tagged nginx:v3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一定不要少了命令中最后的点，下面会有对这个点的说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-t nginx:v3表示要构建的镜像的名称。从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在Step 2中，如同我们之前所说的那样，RUN指令启动了一个容器fdbbe8c89936，执行了所要求的命令，随后删除了所用到的这个容器fdbbe8c89936，并最后提交了这一层b6eed855d34f。</span></span><br></pre></td></tr></table></figure>
<h4 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文(Context)"></a>镜像构建上下文(Context)</h4><blockquote>
<p>如果注意，会看到docker build命令最后有一个”.”。”.”表示当前目录。而Dockerfile就在当前目录，因此不少初学者以为这个路径是在指定Dockerfile所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢?<br>首先我们要理解docker build的工作原理。Docker 在运行时分为 Docker 引擎(也就是服务端守护进程)和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如docker命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种docker功能，但实际上，一切都是使用的远程调用形式在服务端(Docker 引擎)完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<br>当我们进行镜像构建的时候，并非所有定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过COPY指令、ADD指令等。而docker build命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在Dockerfile中这么写:</p>
<figure class="highlight plain"><figcaption><span>./package.json</span><a href="/app/```">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt; 这并不是要复制执行docker build命令所在的目录下的package.json，也不是复制Dockerfile所在目录下的package.json，而是复制上下文(context) 目录下的package.json。</span><br><span class="line">&gt; 因此，&lt;font color=red&gt;COPY这类指令中的源文件的路径都是相对路径。&lt;/font&gt;这也是初学者经常会问的为什么COPY ../package.json /app或者COPY /opt/xxxx /app无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</span><br><span class="line">&gt; 现在就可以理解刚才的命令**docker build -t nginx:v3 .** 中的这个 **.** ，实际上是在指定上下文的目录，docker build命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果观察docker buile的输出，我们其实已经看到了这个发送上下文的过程，如下：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```shell</span><br><span class="line">&gt; root@ruopu:~/mynginx# docker build -t nginx:v3 .</span><br><span class="line">&gt; Sending build context to Docker daemon  2.048kB</span><br><span class="line">&gt; ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<font color="red">理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现COPY /opt/xxxx /app不工作后，于是干脆将Dockerfile放到了硬盘根目录去构建，结果发现docker build执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让docker build打包整个硬盘，这显然是使用错误。</font><br><font color="red">一般来说，应该会将Dockerfile置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用.gitignore一样的语法写一个.dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</font>

<p>那么为什么会有人误以为”.”是指定Dockerfile所在目录呢？这是因为在默认情况下，如果不额外指定Dockerfile的话，会将上下文目录下的名为Dockerfile的文件作为Dockerfile。</p>
<font color="red">这只是默认行为，实际上Dockerfile的文件名并不要求必须为Dockerfile，而且并不要求必须位于上下文目录中，比如可以用-f ../Dockerfile.php 参数指定某个文件作为Dockerfile</font>
</blockquote>
<h4 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 docker build 的用法</h4><h5 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ruopu:~/mynginx# $ docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git\#:8.14</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这行命令指定了构建所需的 Git repo，并且指定默认的master分支，构建目录为/8.14/，然后 Docker 就会自己去git <span class="built_in">clone</span>这个项目、切换到指定分支、并进入到指定目录后开始构建。</span></span><br></pre></td></tr></table></figure>
<h5 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果所给出的 URL 不是个 Git repo，而是个tar压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</span></span><br></pre></td></tr></table></figure>
<h5 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line">或</span><br><span class="line">cat Dockerfile | docker build -</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件COPY进镜像之类的事情。</span></span><br></pre></td></tr></table></figure>
<h5 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果发现标准输入的文件格式是gzip、bzip2以及xz的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</span></span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h3><h4 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 格式:</span><br><span class="line">    COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">    COPY ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 和RUN指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COPY指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。比如:</span></span><br><span class="line">	COPY package.json /usr/src/app/</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;源路径&gt;可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的filepath.Match规则，如:</span></span><br><span class="line">    COPY hom* /mydir/</span><br><span class="line">    COPY hom?.txt /mydir/</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径(工作目录可以用WORKDIR指令来指定)。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此外，还需要注意一点，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用Git进行管理的时候。</span></span><br></pre></td></tr></table></figure>
<h4 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ADD指令和COPY的格式和性质基本一致。但是在COPY基础上增加了一些功能。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如&lt;源路径&gt;可以是一个URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到&lt;目标路径&gt;去。下载后的文件权限自动设置为600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整。另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用RUN指令，然后使用wget或者curl工具下载，处理权限、解压缩，然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果&lt;源路径&gt;为一个tar压缩文件的话，压缩格式为gzip,bzip2以及xz的情况下，ADD指令将会自动解压缩这个压缩文件到&lt;目标路径&gt;去。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像ubuntu中:</span></span><br><span class="line">    FROM scratch</span><br><span class="line">    ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用ADD命令了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 Docker 官方的 Dockerfile 最佳实践文档中要求，尽可能的使用COPY，因为COPY的语义很明确，就是复制文件而已，而ADD则包含了更复杂的功能，其行为也不一定很清晰。最适合使用ADD的场合，就是所提及的需要自动解压缩的场合。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外需要注意的是，ADD指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因此在COPY和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY指令，仅在需要自动解压缩的场合使用ADD。</span></span><br></pre></td></tr></table></figure>
<h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CMD 指令的格式和RUN相似，也是两种格式:</span></span><br><span class="line">	shell 格式：CMD &lt;命令&gt;</span><br><span class="line">	exec 格式：CMD ["可执行文件", "参数1", "参数2"...]</span><br><span class="line">	参数列表格式：CMD ["参数1", "参数2"...]。在指定了ENTRYPOINT指令后，用CMD指定具体的参数。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 之前介绍容器的时候曾经说过，Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用于指定默认的容器主进程的启动命令的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu镜像默认的CMD是/bin/bash，如果我们直接运行docker run -it ubuntu的话，会直接进入bash。我们也可以在运行时指定运行别的命令，如docker run -it ubuntu cat /etc/os-release。这就是用cat /etc/os-release命令替换了默认的/bin/bash命令了，输出了系统版本信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在指令格式上，一般推荐使用<span class="built_in">exec</span>格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号<span class="string">"，而不要使用单引号。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用shell格式的话，实际的命令会被包装为sh -c的参数的形式进行执行。-c选项表示命令从-c后的字符串读取。比如:</span></span><br><span class="line">	CMD echo $HOME</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在实际执行中，会将其变更为：</span></span><br><span class="line">	CMD [ "sh", "-c", "echo $HOME" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提到CMD就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一些初学者将CMD写为:</span></span><br><span class="line">	CMD service nginx start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后发现容器执行后就立即退出了。甚至在容器内去使用systemctl命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而使用service nginx start命令，则是希望 upstart 使用后台守护进程形式启动nginx服务。而刚才说了CMD service nginx start会被理解为CMD [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"service nginx start"</span>] ，因此主进程实际上是sh。那么当service nginx start命令结束后，sh也就结束了，sh作为主进程退出了，自然就会令容器退出。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行。比如:</span></span><br><span class="line">	CMD ["nginx", "-g", "daemon off;"]</span><br></pre></td></tr></table></figure>
<h4 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ENTRYPOINT 的格式和 RUN 指令格式一样，分为<span class="built_in">exec</span>格式和shell格式。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT在运行时也可以替代，不过比CMD要略显繁琐，需要通过docker run的参数--entrypoint来指定。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当指定了ENTRYPOINT后，CMD的含义就发生了改变，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令，换句话说实际执行时，将变为:</span></span><br><span class="line">	&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 那么有了CMD后,为什么还要有ENTRYPOINT呢？这种&lt;ENTRYPOINT&gt; <span class="string">"&lt;CMD&gt;"</span>有什么好处么？让我们来看几个场景。</span></span><br><span class="line"></span><br><span class="line">* 场景一:让镜像变成像命令一样使用</span><br><span class="line"><span class="meta">#</span><span class="bash"> 假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用CMD来实现:</span></span><br><span class="line">    FROM ubuntu:16.04</span><br><span class="line">    RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">    CMD [ "curl", "-s", "http://ip.cn" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 假如我们使用docker build -t myip . 来构建镜像的话,如果我们需要查询当前公网 IP,只需要执行:</span></span><br><span class="line"><span class="meta">	$</span><span class="bash"> docker run myip</span></span><br><span class="line">	当前 IP:61.148.226.66 来自:北京市 联通</span><br><span class="line"><span class="meta">#</span><span class="bash"> 嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的CMD中可以看到实质的命令是curl，那么如果我们希望显示 HTTP头信息，就需要加上-i参数。那么我们可以直接加-i参数给docker run myip么?</span></span><br><span class="line">    $ docker run myip -i</span><br><span class="line">    docker: Error response from daemon: invalid header field value "oci runtime error: con</span><br><span class="line">    tainer_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable</span><br><span class="line">    file not found in $PATH\"\n".</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是<span class="built_in">command</span>，运行时会替换CMD的默认值。因此这里的-i替换了原来的CMD，而不是添加在原来的curl -s http://ip.cn后面。而-i根本不是命令，所以自然找不到。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那么如果我们希望加入-i这个参数，我们就必须重新完整的输入这个命令：</span></span><br><span class="line"><span class="meta">	$</span><span class="bash"> docker run myip curl -s http://ip.cn -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这显然不是很好的解决方案，而使用ENTRYPOINT就可以解决这个问题。现在我们重新用ENTRYPOINT来实现这个镜像:</span></span><br><span class="line">    FROM ubuntu:16.04</span><br><span class="line">    RUN apt-get update \</span><br><span class="line">        &amp;&amp; apt-get install -y curl \</span><br><span class="line">        &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">    ENTRYPOINT [ "curl", "-s", "http://ip.cn" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这次我们再来尝试直接使用docker run myip -i：</span></span><br><span class="line">    $ docker run myip</span><br><span class="line">    当前 IP:61.148.226.66 来自:北京市 联通</span><br><span class="line">    </span><br><span class="line">    $ docker run myip -i</span><br><span class="line">    HTTP/1.1 200 OK</span><br><span class="line">    Server: nginx/1.8.0</span><br><span class="line">    Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">    Content-Type: text/html; charset=UTF-8</span><br><span class="line">    Vary: Accept-Encoding</span><br><span class="line">    X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">    X-Cache: MISS from cache-2</span><br><span class="line">    X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">    X-Cache: MISS from proxy-2_6</span><br><span class="line">    Transfer-Encoding: chunked</span><br><span class="line">    Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">    Connection: keep-alive</span><br><span class="line">    </span><br><span class="line">	当前 IP:61.148.226.66 来自:北京市 联通</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到，这次成功了。这是因为当存在ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT，而这里-i就是新的CMD，因此会作为参数传给curl，从而达到了我们预期的效果。</span></span><br><span class="line"></span><br><span class="line">* 场景二:应用运行前的准备工作</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如mysql类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql 服务器运行之前解决。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此外，可能希望避免使用root用户去启动服务，从而提高安全性，而在启动服务前还需要以root身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root身份执行，方便调试等。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这些准备工作是和容器CMD无关的，无论CMD为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入ENTRYPOINT中去执行，而这个脚本会将接到的参数(也就是&lt;CMD&gt;)作为命令，在脚本最后执行。比如官方镜像redis中就是这么做的：</span></span><br><span class="line">    FROM alpine:3.4</span><br><span class="line">    ...</span><br><span class="line">    RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">    ...</span><br><span class="line">    ENTRYPOINT ["docker-entrypoint.sh"]</span><br><span class="line">    EXPOSE 6379</span><br><span class="line">    CMD [ "redis-server" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了ENTRYPOINT为docker-entrypoint.sh脚本。</span></span><br><span class="line">    #!/bin/sh</span><br><span class="line">    ...</span><br><span class="line">    # allow the container to be started with `--user`</span><br><span class="line">    if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then</span><br><span class="line">    chown -R redis .</span><br><span class="line">    exec su-exec redis "$0" "$@"</span><br><span class="line">    fi</span><br><span class="line">    exec "$@"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 该脚本的内容就是根据CMD的内容来判断，如果是redis-server的话，则切换到redis用户身份启动服务器，否则依旧使用root身份执行。比如：</span></span><br><span class="line">    $ docker run -it redis id</span><br><span class="line">    uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>
<h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* 格式有两种:</span><br><span class="line">    ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">    ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</span></span><br><span class="line">	ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">		NAME="Happy Feet"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方node镜像Dockerfile中，就有类似这样的代码:</span></span><br><span class="line">    ENV NODE_VERSION 7.2.0</span><br><span class="line">    RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta</span><br><span class="line">    r.xz" \</span><br><span class="line">    &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \</span><br><span class="line">    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">    &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">    &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=</span><br><span class="line">    1 \</span><br><span class="line">    &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在这里先定义了环境变量NODE_VERSION，其后的RUN这层里，多次使用<span class="variable">$NODE_VERSION</span>来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新7.2.0即可，Dockerfile构建维护变得更轻松了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下列指令可以支持环境变量展开：</span></span><br><span class="line">	ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBU、ILD</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份Dockerfile制作更多的镜像，只需使用不同的环境变量即可。</span></span><br></pre></td></tr></table></figure>
<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 格式: ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建参数和ENV的效果一样，都是设置环境变量。所不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为docker <span class="built_in">history</span>还是可以看到所有值的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile中的ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build中用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 1.13 之前的版本，要求--build-arg中的参数名，必须在Dockerfile中用ARG定义过了，换句话说，就是--build-arg指定的参数，必须在Dockerfile中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的Dockerfile的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</span></span><br></pre></td></tr></table></figure>
<h4 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 格式为:</span><br><span class="line">    VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</span><br><span class="line">    VOLUME &lt;路径&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</span></span><br><span class="line">	VOLUME /data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里的/data目录就会在运行时自动挂载为匿名卷，任何向/data中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如:</span></span><br><span class="line">	docker run -d -v mydata:/data xxxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在这行命令中，就使用了mydata这个命名卷挂载到了/data这个位置，替代了Dockerfile中定义的匿名卷的挂载配置。</span></span><br></pre></td></tr></table></figure>
<h4 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> EXPOSE指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是docker run -P时，会自动随机映射EXPOSE的端口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker引擎参数--icc=<span class="literal">false</span>，当指定该参数后，容器间将默认无法互访，除非互相间使用了--links参数的容器才可以互通，并且只有镜像中EXPOSE所声明的端口才可以被访问。这个--icc=<span class="literal">false</span>的用法，在引入了docker network后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要将EXPOSE和在运行时使用-p &lt;宿主端口&gt;:&lt;容器端口&gt;区分开来。-p是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而EXPOSE仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</span></span><br></pre></td></tr></table></figure>
<h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 格式为 WORKDIR &lt;工作目录路径&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用WORKDIR指令可用来指定工作目录(或者称为当前目录)，以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR会帮你建立目录。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之前提到一些初学者常犯的错误是把Dockerfile等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误:</span></span><br><span class="line">	RUN cd /app</span><br><span class="line">	RUN echo "hello" &gt; world.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果将这个Dockerfile进行构建镜像运行后，会发现找不到/app/world.txt文件，或者其内容不是hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行RUN命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之前说过每一个RUN都会启动一个容器、执行命令、然后提交存储层文件变更。第一层RUN <span class="built_in">cd</span> /app的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器完全没关系，自然不可能继承前一层构建过程中的内存变化。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因此如果需要改变以后各层的工作目录的位置，那么应该使用WORKDIR指令。</span></span><br></pre></td></tr></table></figure>
<h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* 格式: USER &lt;用户名&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的执行RUN，CMD以及ENTRYPOINT这类命令的身份。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然，和WORKDIR一样，USER只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</span></span><br><span class="line">    RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">    USER redis</span><br><span class="line">    RUN [ "redis-server" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果以root执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用su或者sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用gosu。</span></span><br><span class="line"></span><br><span class="line">   RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line">    RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/</span><br><span class="line">    gosu-amd64" \</span><br><span class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">    &amp;&amp; gosu nobody true  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 gosu</span></span><br><span class="line">  CMD [ "exec", "gosu", "redis", "redis-server" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 CMD，并以另外的用户执行</span></span><br></pre></td></tr></table></figure>
<h4 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">* 格式:</span><br><span class="line">	HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">	HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line"><span class="meta">#</span><span class="bash"> HEALTHCHECK指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12引入的新指令。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在没有HEALTHCHECK指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而自 1.12 之后，Docker 提供了HEALTHCHECK指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当在一个镜像指定了HEALTHCHECK指令后，用其启动容器，初始状态会为starting，在HEALTHCHECK指令检查成功后变为healthy，如果连续一定次数失败，则会变为unhealthy。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HEALTHCHECK 支持下列选项：</span></span><br><span class="line">--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；</span><br><span class="line">--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</span><br><span class="line">--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为unhealthy，默认 3次。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 和CMD，ENTRYPOINT一样，HEALTHCHECK只可以出现一次，如果写了多个，只有最后一个生效。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在HEALTHCHECK [选项] CMD后面的命令，格式和ENTRYPOINT一样，分为shell格式，和<span class="built_in">exec</span>格式。命令的返回值决定了该次健康检查的成功与否，0：成功；1：失败；2：保留，不要使用这个值。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用curl来帮助判断，其Dockerfile的HEALTHCHECK可以这么写：</span></span><br><span class="line">    FROM nginx</span><br><span class="line">    RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">    HEALTHCHECK --interval=5s --timeout=3s \</span><br><span class="line">    CMD curl -fs http://localhost/ || exit 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里我们设置了每 5 秒检查一次(这里为了试验所以间隔非常短，实际应该相对较长)，如果健康检查命令超过 3 秒没响应就视为失败，并且使用curl -fs http://localhost/ || <span class="built_in">exit</span> 1 作为健康检查命令。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docker build来构建这个镜像：</span></span><br><span class="line"><span class="meta">	$</span><span class="bash"> docker build -t myweb:v1 .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建好了后，我们启动一个容器:</span></span><br><span class="line"><span class="meta">	$</span><span class="bash"> docker run -d --name web -p 80:80 myweb:v1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当运行该镜像后，可以通过docker container ls看到最初的状态为(health: starting):</span></span><br><span class="line">    $ docker container ls</span><br><span class="line">    CONTAINER ID	IMAGE	COMMAND		CREATED		 STATUS		PORTS		NAMES</span><br><span class="line">	03e28eb00bd0	myweb:v1	"nginx -g 'daemon off"	3 seconds ago Up 2 seconds (health: starting)	80/tcp, 443/tcp		web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在等待几秒钟后，再次docker container ls，就会看到健康状态变化为了(healthy):</span></span><br><span class="line"><span class="meta">	$</span><span class="bash"> docker container ls</span></span><br><span class="line">	CONTAINER ID	IMAGE	COMMAND		CREATED		STATUS		PORTS		NAMES</span><br><span class="line">	03e28eb00bd0	myweb:v1	"nginx -g 'daemon off"	18 seconds ago Up 16 seconds (healthy)	80/tcp, 443/tcp		web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果健康检查连续失败超过了重试次数，状态就会变为(unhealthy)。	</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了帮助排障，健康检查命令的输出(包括stdout以及stderr)都会被存储于健康状态里，可以用docker inspect来查看。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect --format <span class="string">'&#123;&#123;json .State.Health&#125;&#125;'</span> web | python -m json.tool</span></span><br><span class="line">&#123;</span><br><span class="line">    "FailingStreak": 0,</span><br><span class="line">    "Log": [</span><br><span class="line">		&#123;</span><br><span class="line">            "End": "2016-11-25T14:35:37.940957051Z",</span><br><span class="line">            "ExitCode": 0,</span><br><span class="line">            "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/titl</span><br><span class="line"><span class="meta">e&gt;</span><span class="bash">\n&lt;style&gt;\n	body &#123;\n	width: 35em;\n	margin: 0 auto;\n	font-family: Tahoma, Verdana, Arial, sans-serif;\n	&#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully inst</span></span><br><span class="line">alled and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentat</span><br><span class="line">ion and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCo</span><br><span class="line">mmercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n",</span><br><span class="line">			"Start": "2016-11-25T14:35:37.780192565Z"</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	"Status": "healthy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* 格式: ONBUILD &lt;其它指令&gt;。</span><br><span class="line"><span class="meta">#</span><span class="bash"> ONBUILD是一个特殊的指令，它后面跟的是其它指令，比如RUN，COPY等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile中的其它指令都是为了定制当前镜像而准备的，唯有ONBUILD是为了帮助别人定制自己而准备的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用npm进行包管理，所有依赖、配置、启动信息等会放到package.json文件里。在拿到程序代码后，需要先进行npm install才可以获得所有需要的依赖。然后就可以通过npm start来启动应用。因此，一般来说会这样写Dockerfile：</span></span><br><span class="line">    FROM node:slim</span><br><span class="line">    RUN mkdir /app</span><br><span class="line">    WORKDIR /app</span><br><span class="line">    COPY ./package.json /app</span><br><span class="line">    RUN [ "npm", "install" ]</span><br><span class="line">    COPY . /app/</span><br><span class="line">    CMD [ "npm", "start" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把这个Dockerfile放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个Dockerfile复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile ，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初Dockerfile是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的Dockerfile，而第二个项目的Dockerfile就会被自动修复。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步Dockerfile的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个Dockerfile就会变为：</span></span><br><span class="line">    FROM node:slim</span><br><span class="line">    RUN mkdir /app</span><br><span class="line">    WORKDIR /app</span><br><span class="line">    CMD [ "npm", "start" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为my-node的话，各个项目内的自己的Dockerfile就变为：</span></span><br><span class="line">    FROM my-node</span><br><span class="line">    COPY ./package.json /app</span><br><span class="line">    RUN [ "npm", "install" ]</span><br><span class="line">    COPY . /app/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基础镜像变化后，各个项目都用这个Dockerfile重新构建镜像，会继承基础镜像的更新。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那么，问题解决了么？没有。准确说，只解决了一半。如果这个Dockerfile里面有些东西需要调整呢？比如npm install 都需要加一些参数，那怎么办？这一行RUN是不可能放入基础镜像的，因为涉及到了当前项目的./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的Dockerfile的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ONBUILD可以解决这个问题。让我们用ONBUILD重新写一下基础镜像的Dockerfile：</span></span><br><span class="line">    FROM node:slim</span><br><span class="line">    RUN mkdir /app</span><br><span class="line">    WORKDIR /app</span><br><span class="line">    ONBUILD COPY ./package.json /app</span><br><span class="line">    ONBUILD RUN [ "npm", "install" ]</span><br><span class="line">    ONBUILD COPY . /app/</span><br><span class="line">    CMD [ "npm", "start" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这次我们回到原始的Dockerfile，但是这次将项目相关的指令加上ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的Dockerfile就变成了简单地:</span></span><br><span class="line">	FROM my-node</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是的，只有这么一行。当在各个项目目录中，用这个只有一行的Dockerfile构建镜像时，之前基础镜像的那三行ONBUILD就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行npm install，生成应用镜像。</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/docker学习二：安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/docker学习二：安装/" itemprop="url">
                  docker学习二：安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-20 13:01:32" itemprop="dateCreated datePublished" datetime="2018-09-20T13:01:32+08:00">2018-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2018-12-19 11:53:54" itemprop="dateModified" datetime="2018-12-19T11:53:54+08:00">2018-12-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Container/" itemprop="url" rel="index"><span itemprop="name">Container</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ubuntu18-04-Server"><a href="#ubuntu18-04-Server" class="headerlink" title="ubuntu18.04_Server"></a>ubuntu18.04_Server</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">apt install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于apt源使用 HTTPS 以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS 传输的软件包以及 CA 证书。</span></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</span></span><br><span class="line">add-apt-repository  "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向source.list中添加 Docker 软件源</span></span><br><span class="line">apt update</span><br><span class="line">apt install docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">groupadd docker</span><br><span class="line">usermod -aG docker test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前用户加入docker组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下,docker命令会使用 Unix socket 与 Docker 引擎通讯。而只有root用户和组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑,一般 Linux 系统上不会直接使用root用户。因此,更好地做法是将需要使用docker的用户加入docker用户组。</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">    &#123;</span><br><span class="line">      "registry-mirrors":[</span><br><span class="line">        "https://87uxhe5.mirror.aliyuncs.com"</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置docker加速器，地址是从阿里云的容器镜像服务器得到的</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试docker安装是否成功。如果安装成功，会输入下列内容</span></span><br><span class="line">    Hello from Docker!</span><br><span class="line">    This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">    To generate this message, Docker took the following steps:</span><br><span class="line">     1. The Docker client contacted the Docker daemon.</span><br><span class="line">     2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">        (amd64)</span><br><span class="line">     3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">        executable that produces the output you are currently reading.</span><br><span class="line">     4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">        to your terminal.</span><br><span class="line"></span><br><span class="line">    To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">     $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">    Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line">     https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">    For more examples and ideas, visit:</span><br><span class="line">     https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<h1 id="Kali3-0"><a href="#Kali3-0" class="headerlink" title="Kali3.0"></a>Kali3.0</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apt-key adv \--keyserver hkp://ha.pool.sks-keyservers.net:80 \--recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加key</span></span><br><span class="line">vim /etc/apt/sources.list</span><br><span class="line">		deb https://apt.dockerproject.org/repo debian-wheezy main</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加源</span></span><br><span class="line">apt update</span><br><span class="line">apt install docker-engine</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://www.jianshu.com/p/6b1cb6927e9e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Docker官网地址：https://docs.docker.com/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Debian安装Docker官方教程：https://docs.docker.com/engine/installation/linux/debian/</span></span><br></pre></td></tr></table></figure>
<h1 id="Windows7"><a href="#Windows7" class="headerlink" title="Windows7"></a>Windows7</h1><ol>
<li>下载DockerToolbox，地址：<a href="https://github.com/docker/toolbox/releases" target="_blank" rel="noopener">https://github.com/docker/toolbox/releases</a></li>
<li>安装中，如果VirualBox和Git已经安装，可以不选</li>
</ol>
<p><img src="\images\docker\docker1.jpg" alt=""></p>
<ol start="3">
<li>安装完成后，桌面上会多出3各图标，如下。其中VirtualBox提供了linux虚拟机的运行环境，Docker Quickstart Terminal用于快速介入linux虚拟机，提供命令行交互，Kitematic是docker GUI很少用到。</li>
</ol>
<p><img src="\images\docker\docker2.jpg" alt=""></p>
<ol start="4">
<li>使用命令创建default虚拟机</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打开cmd</span><br><span class="line">docker-machine create default</span><br></pre></td></tr></table></figure>
<p><img src="\images\docker\docker3.jpg" alt=""></p>
<p>启动时会进行Docker环境的初始化，会在VirtualBox中自动创建名字为default的linux虚拟机，在此过程中会用到boot2docker.iso镜像文件。默认情况下，启动程序会从GitHub上下载此文件的最新版，但由于文件相对较大且速度不给力，多数情况下会下载失败，造成Docker环境无法启动。解决办法：其实DockerToolbox安装文件自带了boot2docker.iso镜像文件，位于安装目录下（如C:\Program Files\Docker Toolbox） ，将此文件拷至C:\Users\Administrator.docker\machine\cache目录下，然后在<strong>网络断开</strong>的情况下重新启动，便可初始化成功。</p>
<ol start="5">
<li>查看default虚拟机的IP地址，使用Xshell连接</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打开cmd</span><br><span class="line">docker-machine ls</span><br><span class="line"><span class="meta">#</span><span class="bash">查看default地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">登录default信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名：docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">密码：tcuser</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>更改虚拟磁盘存储位置</li>
</ol>
<p>虚拟机的默认存储位置是C:\Users\Administrator.docker\machine\machines ，后期docke镜像文件会不断增加，为了给系统盘减负，最好将磁盘移动到其他位置。</p>
<ul>
<li>首先通过PowerShell或cmd终端中执行【docker-machine stop default】命令停止default虚拟机。</li>
</ul>
<p><img src="\images\docker\docker4.jpg" alt=""></p>
<ul>
<li>通过VirtualBox”管理”–&gt;”虚拟介质管理”界面对虚拟磁盘进行复制。之后添加新磁盘，删除旧磁盘即可</li>
</ul>
<p><img src="\images\docker\docker5.jpg" alt=""></p>
<p><img src="\images\docker\docker6.jpg" alt=""></p>
<p><img src="\images\docker\docker7.jpg" alt=""></p>
<p><img src="\images\docker\docker8.jpg" alt=""></p>
<p><img src="\images\docker\docker9.jpg" alt=""></p>
<p><img src="\images\docker\docker10.jpg" alt=""></p>
<p><img src="\images\docker\docker11.jpg" alt=""></p>
<p><img src="\images\docker\docker12.jpg" alt=""></p>
<p><img src="\images\docker\docker13.jpg" alt=""></p>
<p><img src="\images\docker\docker14.jpg" alt=""></p>
<p><img src="\images\docker\docker15.jpg" alt=""></p>
<ol start="7">
<li>配置镜像加速器</li>
</ol>
<p>登录阿里云<a href="https://cr.console.aliyun.com，点击右侧的镜像加速器，复制地址。最后用命令修改镜像地址即可" target="_blank" rel="noopener">https://cr.console.aliyun.com，点击右侧的镜像加速器，复制地址。最后用命令修改镜像地址即可</a></p>
<p><img src="\images\docker\docker16.jpg" alt=""></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">登录虚拟机default</span><br><span class="line">sudo sed -i "s|EXTRA_ARGS='|EXTRA_ARGS='--registry-mirror=加速地址 |g" /var/lib/boot2docker/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">修改后，可调整default的硬件配置，如CPU，memory，disk等，disk可以不用复制，创建一个新的，大一点的空间。另外，不可取消光驱的启动，因为启动时要用到boot2docker.iso文件</span></span><br><span class="line">打开cmd</span><br><span class="line">docker-machine restart default</span><br><span class="line"><span class="meta">#</span><span class="bash">重启docker服务</span></span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.cnblogs.com/canger/p/9028723.html" target="_blank" rel="noopener">https://www.cnblogs.com/canger/p/9028723.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/阿里云日志文件备份/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/阿里云日志文件备份/" itemprop="url">
                  阿里云日志文件备份
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-18 16:09:41" itemprop="dateCreated datePublished" datetime="2018-09-18T16:09:41+08:00">2018-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2018-11-21 10:56:20" itemprop="dateModified" datetime="2018-11-21T10:56:20+08:00">2018-11-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/阿里云/" itemprop="url" rel="index"><span itemprop="name">阿里云</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>密钥访问</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 准备备份日志的服务器</span><br><span class="line">ssh-keygen -t rsa -P ''</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.2.250</span><br></pre></td></tr></table></figure>
<ul>
<li>脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim /root/sh</span><br><span class="line">    #!/bin/bash</span><br><span class="line">    #</span><br><span class="line">    nettylog=/apps/echarging/log/nettylog</span><br><span class="line">    processorlog=/apps/echarging/log/processor_1_log</span><br><span class="line">    nettyback=/home/nettylog</span><br><span class="line">    processorback=/home/processorlog1</span><br><span class="line">    nettybackR=/home/logbackup/nettylog</span><br><span class="line">    processorbackR=/home/logbackup/processorlog1</span><br><span class="line"></span><br><span class="line">    cd $nettylog</span><br><span class="line">    find ./ -name netty.log-`date -d yesterday +%F`."*".log -exec cp &#123;&#125; $nettyback \;</span><br><span class="line">    tar -zcf $nettyback/netty-log.`date -d yesterday +%F`.tar.gz $nettyback/*.log</span><br><span class="line">    scp $nettyback/netty-log.`date -d yesterday +%F`.tar.gz 192.168.2.250:$nettybackR</span><br><span class="line">    rm -rf $nettyback/*</span><br><span class="line"></span><br><span class="line">    cd $processorlog</span><br><span class="line">    find ./ -name processor_1.log-`date -d yesterday +%F`."*".log -exec cp &#123;&#125; $processorback \;</span><br><span class="line">    tar -zcf $processorback/processor_1.log-`date -d yesterday +%F`.tar.gz $processorback/*.log</span><br><span class="line">    scp $processorback/processor_1.log-`date  -d yesterday +%F`.tar.gz 192.168.2.250:$processorbackR</span><br><span class="line">    rm -rf $processorback/*</span><br><span class="line"><span class="meta">#</span><span class="bash">本打算使用find ./ -name processor_1.log-`date -d yesterday +%F`.<span class="string">"*"</span>.<span class="built_in">log</span> -<span class="built_in">exec</span> tar -zcf processor_log-`date -d yesterday +%F`.tar.gz &#123;&#125; \;命令来直接打包，但测试发现打出的包中只有find查到的最后一个文件。所以将命令改为了两条，先将找到的文件移到一个临时目录，再打包发送。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定时任务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">	* 4 * * * /bin/bash /root/sh/scplog.sh</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/阿里云RDS数据库备份下载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruopu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruopu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/阿里云RDS数据库备份下载/" itemprop="url">
                  阿里云RDS数据库备份下载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              

              
                
              

              <time title="創建時間：2018-09-18 10:20:56" itemprop="dateCreated datePublished" datetime="2018-09-18T10:20:56+08:00">2018-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新於</span>
                
                <time title="修改時間：2018-11-21 10:54:58" itemprop="dateModified" datetime="2018-11-21T10:54:58+08:00">2018-11-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/阿里云/" itemprop="url" rel="index"><span itemprop="name">阿里云</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>下载RDS数据备份或日志备份</p>
<ol>
<li>登录RDS管理控制台</li>
<li>选择目标实例所在地域。</li>
<li>单击目标实例的ID，进入基本信息页面</li>
<li>在左侧导航栏中，选择备份恢复，进入备份恢复页面</li>
<li>选择数据备份标签页</li>
<li>选择查询的时间范围，然后单击查询。</li>
<li>在数据备份列表中，找到要下载的数据备份，并单击其对应的下载</li>
<li>在实例备份文件下载窗口，单击复制外网地址，获取数据备份文件外网下载地址。这里可以直接下载到本地，也可以通过内网或外网地址下载</li>
<li>登录云服务器ECS</li>
<li>下载数据备份文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -c '&lt;数据备份文件内网或外网下载地址&gt;' -O &lt;自定义文件名&gt;.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">-c：启用断点续传模式。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-O：将下载的结果保存为指定的文件（建议使用URL中包含的文件名）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">说明：若提示显示100%进度，则表示文件下载完成。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一頁"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ruopu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">134</span>
                    <span class="site-state-item-name">文章</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">分類</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">102</span>
                    <span class="site-state-item-name">標籤</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ruopu</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 強力驅動 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主題 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
