---
title: python算法-插入排序
date: 2019-11-11 08:19:40
tags: 算法
categories: python
---

### 直接插入排序 Direct Insertion Sort

- 直接插入排序原理
  - 在未排序序列中，构建一个子排序序列,直至全部数据排序完成
  - 将待排序的数，插入到***已经排序***的序列中合适的位置
  - 增加一个哨兵，放入待比较值，让它和后面已经排好序的序列比较，找到合适的插入点

![](/media/shouyu/C64CC89B4CC8879F/works/GitHub/ruopu89.github.io/themes/hexo-theme-next/source/images/python插入排序/插入排序1.png)
  - 初始的0及下面开头的红色数字为哨兵，即待插入值

  - 从第二个数字开始排序，即9

  - 第一趟，哨兵是9，用1和哨兵比较，1小，哨兵插入，本轮比较结束

  - 第二趟，哨兵是8，用9和哨兵比较大于哨兵，9向右移，1和哨兵比较，1小，哨兵插入本轮比较结束

  - 以此类推，直至把最后一个数字放到哨兵并比较，插入完成

```python
m_list = [[1,9,8,5,6,7,4,3,2],[1,2,3,4,5,6,7,8,9],[9,8,7,6,5,4,3,2,1],[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,2]]
nums = [0] + m_list[0]    # nums为[0,1,9,8,5,6,7,4,3,2]
# print(nums)
sentinel,*origin = nums   # 哨兵位，待比较数字。sentinel为0，origin为[1,9,8,5,6,7,4,3,2]
# print(sentinel)
# print(origin)
count_swap = 0   # 计算每轮循环中，与哨兵位比较后要交换的次数
count_iter = 0   # 计算从第二个数字到最后一个数字，一共要循环的资源
length = len(nums)
for i in range(2,length):   # 从第二个数字开始
    nums[0] = nums[i]    
# 放置哨兵，把比较的数字赋值给第一个数字，第一个数字就是哨兵位。如第一次就是把9放到哨兵位。这里的哨兵是在按列表中的数字不停顺序变化的，
# ，第一次是9，之后是8,5,6，一直到最后，如果要比较的数字比哨兵位的数字小，就不动，如果比哨兵位的数字大，就向右移
    j = i - 1    # 得出要比较数字的索引位置，下面就要用1和9比较
    count_iter += 1
    if nums[j] > nums[0]:    # 大数右移，找到插入位置。如果要比较的数字比哨兵位的数字大
        while nums[j] > nums[0]:
            nums[j+1] = nums[j]    # 依次右移
            j -= 1
# 如果索引j比哨兵位的数字大，就把索引j向后移一个位置，之后把索引j减1，再进行同样的比较。当8是哨兵位时，9与8比较，因为比8大，就会把9
# 的索引向后移动，之后再用1和哨兵位的8比较，1小于8,那么执行下面的哨兵插入，这时正好插入到了之前9的位置
            count_swap += 1
        nums[j+1] = nums[0]    # 将哨兵插入，注意插入在右侧要+1
print(nums, count_swap, count_iter)
输出：
[2, 1, 2, 3, 4, 5, 6, 7, 8, 9] 25 8
# 可以看到最后一个数字2在哨兵位上。
```

- 增加一个哨兵位，每轮比较将待比较数放入
- 哨兵依次和待比较数的前一个数据比较，大数向右移动，找到哨兵中值的插入位置
- 每一轮结束后，得到一个从开始到待比较数位置的一个有序序列
- 最好情况，正好是升序排列，比较迭代n-1次
- 最差情况，正好是降序排列，比较迭代1,2,...,n-1即n(n-1)/2
- 使用两层嵌套循环，时间复杂度O(n^2)
- 稳定排序算法
- 使用在小规模数据比较
- 优化
  - 如果比较操作耗时大的话，可以采用二分查找来提高效率，即二分查找插入排序